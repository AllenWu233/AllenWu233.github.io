[{"content":"正文 我自造的一个概念：在一定时间段内，所接收的非熟悉的信息密度越大，时间感密度就越大，而体感上时间的流逝就越慢。这里非熟悉信息可定义为日常生活中不容易重复的经历，是全新的体验。常见于旅行、参加同人展会、听 Live 、参加大型比赛等。\n比如这次的 #2025广州THO_东方乐典 ，三天两夜的行程，就好像过了三周。大概是因为日常平平无奇，每天的日程都差不多，接触的大多是熟悉信息；而这次行程排得满满当当——跟群友网友面基、玩无线电、跑 THO、听 Live，刺激了松驰已久的神经，无时无刻不是新鲜的体验。\n不知心理学是否已有类似的概念？\n（问了一下 LLM，还真有）\nLLM Hunyuan 你提出的“时间感密度”概念与心理学中多个研究方向高度契合，尤其在时间感知（time perception）和时间知觉（time perception）领域已有相关理论支撑。以下从概念关联性、神经机制、影响因素及应用场景等角度综合分析：\n一、与心理学概念的关联性\n时间折叠效应（Time Folding Effect）\n该效应指大脑通过信息密度和记忆编码方式压缩或延展主观时间感。当新体验（如旅行、新技能学习）带来高密度、高复杂度的感官输入时，大脑会将其编码为更丰富的记忆片段，回忆时会产生“时间被拉长”的错觉。例如，童年假期因新奇体验多而被认为漫长，而重复的成年生活因记忆稀疏显得短暂。\n经验密度与时间流逝感\n心理学研究提出，经验密度（Experiential Density）是影响时间感知的核心变量。高密度经验（如密集的新信息、情绪波动）会增强时间的主观延续性，而低密度经验（如重复性任务）则导致时间压缩。例如，THO展会中频繁的面基、无线电活动等新刺激，显著提升了经验密度，使两天行程被感知为更长时间。\n注意资源分配理论\n大脑通过注意力闸门模型调节时间感知：当注意力集中于新异刺激时，内部时钟的脉冲计数减少，主观时间流逝加快；反之，若注意力分散或被迫处理冗余信息，脉冲计数增加，时间感延长。你的案例中，THO活动的高专注与新奇性可能触发了注意力的动态分配，导致时间感密度提升。\n二、神经机制支持\n基底神经节与多巴胺系统\n基底神经节负责时间间隔的编码，而多巴胺水平影响其对时间间隔的估计。新异体验会激活多巴胺能通路，增强神经元放电频率，导致主观时间分辨率提高（即更精细的时间划分），从而延长体感时间。\n海马与情景记忆整合\n海马体通过整合感官输入构建时空记忆。高密度新体验会触发海马-前额叶皮层协同作用，形成更复杂的记忆网络，回忆时因信息量庞大而产生“时间膨胀”效应。\n默认模式网络（DMN）的抑制\n当大脑处于心流状态（如专注听Live、参与无线电活动）时，默认模式网络活动降低，前额叶-顶叶网络主导的自我参照加工增强，抑制对时间流逝的监控。\n三、影响因素扩展\n情绪强度\n积极情绪（如兴奋、好奇）通过抑制杏仁核对威胁信号的关注，减少时间监控脑区（如基底神经节）的资源分配，间接延长主观时间。\n认知负荷\n高难度任务（如学习新技能）需要更多认知资源，减少对时间信息的处理，导致时间感压缩；但若任务兼具新异性与挑战性（如THO活动中的多线程体验），可能因情绪唤醒与信息过载共同作用，反而延长时间感。\n文化背景\n东方文化对循环时间的感知（如节气、节庆）可能增强对密集事件的记忆锚点，而西方线性时间观更依赖物理计时工具。你的体验可能受文化习惯影响，更易将新事件序列编码为“非重复性时间块”。\n四、应用场景与建议\n时间管理优化\n• 主动设计高密度体验：通过旅行、技能学习等增加经验密度，缓解日常时间压缩感。\n• 打破重复性：定期改变通勤路线、尝试新活动，利用“新异刺激-时间感延长”机制提升生活体验。\n心理健康干预\n• 正念训练：通过冥想等降低注意力分散，增强对时间流逝的觉察，缓解焦虑性时间压缩。\n• 创伤后应激：利用时间膨胀体验（如回忆重构）帮助患者重新整合创伤记忆的时间维度。\n艺术与设计\n• 影视剪辑：通过快速切换镜头（高信息密度）制造“慢镜头”效果，强化观众的时间感知。\n• 游戏设计：利用任务嵌套与多线程玩法，延长玩家主观游戏时长而不增加实际耗时。\n五、总结 你的“时间感密度”概念与心理学中的时间折叠效应、经验密度理论及注意资源分配模型高度一致，其核心在于新异刺激通过改变信息处理模式与记忆编码强度，重塑主观时间感知。未来可进一步结合神经影像学（如fMRI）验证不同活动类型对时间知觉相关脑区的影响，或探索其在教育、用户体验设计中的实践价值。\nChatGPT-4o 深度研究 明白了，我会帮你查找心理学中是否存在与你提出的“时间感密度”概念相近的理论或术语，包括认知心理学、时间知觉、注意力与记忆等领域，覆盖中文与英文资料。 我会尽快整理并告诉你有哪些已有概念与“在有限时间内经历越多新鲜信息，体感时间越慢”这一体验有关联。\n“时间感密度”现象概述 用户提出的“时间感密度”指在同一段时间内经历的事件或新奇信息越多，主体感知到的时间就越“慢”。这种现象与旅行、展会、演唱会等丰富刺激场景相关。心理学研究表明：回顾性地看，经历丰富、多样的事件会让一段时间的记忆更加充实，从而感觉更漫长。例如，有研究指出：“回程通常比去程感觉短，可能是因为沿路景象的新奇感消失了”；新闻报道也提到，首次去新的城市旅行会让人觉时间格外漫长。总之，在记忆层面，多事件、多变化对应更多编码内容，因而给人“时间延长”的印象。\n记忆视角：情境变化与存储体积 记忆模型（storage-size/contextual-change 模型）强调，一段时间内被记忆下的事件越多、越复杂，回顾时感觉持续时间越长。经典研究发现：包含多种不同任务或事件的时段，被试回忆时会感觉更长。James (1890) 和 Ornstein (1969) 均指出：“记忆的多产性越高”，信息储存容量越大，主观持续感就越长。例如，孩子在童年经历许多“第一次”，这些新奇体验在脑海中印象深刻，回忆时倍感充实；而成年后生活趋于日常重复，回忆内容减少，导致感觉时间压缩、过得更快。这些证据与“时间感密度”强调的多经历→时间拖长相符。\n注意力与认知负荷 从前瞻性时间估计看，注意力和任务负荷起关键作用。注意力-门控模型认为，当注意力更多地集中于当前事件（而非时间本身），内部时钟脉冲增多、持续时间被低估；相反，当空闲无聊时，注意力会落到时间流逝上，感觉时间变慢。元分析发现：高认知负荷下进行时间估计，若被试事先知道要计时（前瞻性任务），主观时间比率降低（低估时长）；但若在事后回忆（回顾性任务），高负荷反而让时长感增大。换言之，在繁忙复杂的体验中，当事人往往觉得“时间飞快”，而回头看却会觉得“经历了更多”，反映负荷与时间感知的双向影响。就“时间感密度”而言，如果将其视为回顾式感觉，那么高事件密度确实与更长的时间感相符；但从前瞻性角度，这与常说的“多任务时光飞逝”相反。\n新奇性影响 新奇刺激通常会扩张主观时间感。重复出现的刺激因神经适应而被感知更短，而突然出现的新奇刺激则被感觉更长。Eagleman 等人发现，相同时长的视频片段若以慢动作播放（新奇度低），观察者反而认为经过的时间更短；大量心理学研究也表明，新奇事物会让人感觉持续时间异常漫长。类似地，在“稀有刺激”实验（oddball paradigm）中，低概率出现的新奇刺激往往被估计为持续时间更长（即主观时间扩张）。这一切说明：新颖性会抓住注意力并丰富信息编码，从而拉长时间感。这与用户所说的“越多新奇信息→时间越慢”是一致的。\n相关术语 心理学文献中没有“时间感密度”这一标准术语，但有几个相关表达可参照：\n体验/事件密度 (event density/experience density)：指单位时间内经历或记忆的事件数量。文献中的“事件密度假说 (event-density hypothesis)”提出，事件数量影响时间感，尽管该假说一般用来解释“事件多→感觉时间压缩（快过）”的情况。 主观时间扩张/膨胀 (subjective time expansion/dilation)：用于描述新奇刺激或情感高涨时主观持续延长的现象。在研究中，新奇/稀有刺激常被认为“看起来持续更长”。 存储量假说 (storage-size hypothesis)、情境变化假说 (contextual-change hypothesis)：强调记忆编码量或认知情境变化与时长估计的关系。虽然不是用来描述“体验密度”，但含义接近。 在中文网络或科普中，人们也会用“体验密度”、“事件密度”等说法来形容类似感觉。例如，有文章指出“新鲜体验会让大脑形成更深刻记忆，第一次去一个新城市旅行感觉时间特别漫长”。 中文讨论与比较 国内媒体和论坛已有类似讨论。例如《新浪财经》专栏提到“第一次坐火车时觉得时光漫长”，“童年很多‘第一次’，新鲜独特的经历都深深印刻在脑海”；温哥华天空健康专栏也强调“新奇事物让大脑处理更积极，记忆更丰富”，因此回忆过去时“感觉时间更长”。这些讨论与“时间感密度”概念吻合：新奇体验越多，回忆时觉得时间越多、越慢。\n总结： “时间感密度”与已有心理学概念最接近的是记忆模型中的事件/体验密度。相关理论（如存储量假说、情景变化假说）都认为多事件或新奇经历会拉长主观时长。英文中可近似说为“experience/event density”或“subjective time expansion”。需注意的是，传统前瞻性时间感研究（注意力门控模型等）往往指出事件越多、任务越复杂人们会感觉时间过得越快；这与“时间感密度”假设的越多体验→越慢存在差异。总体而言，用户概念更契合于回顾性时间知觉和记忆丰富度的视角，这在心理学中已被多项研究所验证，但学术术语主要围绕“事件密度”、“时间扩张”等来表述。\n主要参考文献： Block 和 Reed (1978) 等关于情景变化模型的经典研究；Eagleman (2009) 等关于重复与新奇刺激对时间知觉影响的研究；以及近年来对时间知觉与事件密度的综述。中文网络文章如《新浪财经》、《温哥华天空》等也提供了对该现象的通俗解释。以上资料帮助我们理解“时间感密度”这一概念的心理学背景和相似概念。\nAllen：整理一个更精炼、系统的定义版本，既保留我的直觉，又贴近心理学术语\n当然可以，这是一个精炼、系统化的版本，在保留你原有直觉的基础上，结合心理学术语表达如下：\n🧠 时间感密度（Temporal Experience Density） 定义： 时间感密度是指在特定时间段内，个体接收的新奇、非自动化、情境变化多的体验信息的密度。时间感密度越高，个体在主观感知上对时间的流逝越缓慢，回顾该时段时也更倾向于感到其“内容丰富、时间漫长”。\n补充说明（可选用于学术或科普场合）：\n该概念融合了心理学中对回顾性时间知觉（retrospective time perception）、情境变化假说（contextual-change hypothesis） 与新奇性处理（novelty encoding） 的理解。 高时间感密度常出现于旅行、展会、初次社交、大量多样任务集中发生的时期。 与“时间飞逝”（time flies）相反，它强调：体验越密集，记忆越丰富，时间体感越“被拉长”。 如你愿意继续发展这个概念，它完全可以用于做成一篇心理学随笔、讲座内容，甚至正式论文的“自变量设定”。需要我帮你做术语图谱或视觉化也可以说。\n","permalink":"https://blog.allenwu233.com/zh/posts/temporal-experience-density/","summary":"“哥们深夜研究心理学”","title":"时间感密度"},{"content":"前言 作为一名不资深“碟佬”（CD 爱好者），收藏常规 CD 的同时，自然也少不了一些奇奇怪怪的收藏。特别是一些古早的同人 CD，往往做得奇形怪状，例如 32 开本大小的 CD，跟普通 CD 放在一起，显得格格不入。\n前段时间有幸收到了 《現夢 -genmu-》 ——2011 年发售的东方 Project 同人 CD，包装是纯纸盒的，里面是两张光盘和两本小册子——可费了我不小的一笔零花钱。保护措施自然要拉满：防潮、防压、防震，不然哪天发生什么意外——特别是毕业搬东西回家——把这宝贵的收藏给弄坏了，那是生理上（钱包）和心理上的双重打击。\n目前的保护措施仅做到防潮：两个防潮自封袋，袋装盒，袋套袋。显然这点根本不够，有必要上保护盒了。当成传家宝供起来（？） 一番研究后，我决定为 CD 定制一个保护盒。\n保护盒设计 CD 加上单层防潮袋的体积为：200x150x20 mm。\n于是，我打算定制一款书型翻盖式盒子（有点像月饼盒）。内衬用两块海绵：底下是 265x185x47.5 mm，中间挖去一个 200x150x20 mm 的凹槽；盖子是一块 265x185x27.5 mm。这么一来，CD 能完美地被固定在海棉中间，外层还有硬纸壳的保护，防潮、防压、防震三位一体，应该没什么问题了罢。\n底部的俯视图草图如下： 一波三折 纸盒定制 一开始，我打算直接在某宝、某鱼上定制整盒带内衬，但价格令人汗颜：动辄就要 200 元以上。因为这些商家大多是面向大批量订单的客户，像我这种“散户”，定制一个显然不划算，只能另辟蹊径。\n在某宝逛了一圈，突然想到可以买现成的盒子，然后定制内衬，不是会更划算吗？\n一不做二不休，还真给我找到了，尺寸和价格也合适：\n内衬定制 内衬我选了黑色 EVA：一种新型环保塑料发泡材料，具有良好的缓冲、抗震、隔热、防潮、抗化学腐蚀等优点，且无毒、不吸水，广泛用于电子电器的防震防滑、密封保温、各种包装盒和金属罐内衬等。虽然会有一点气味，但放室外通几天风基本也能散去。介意的朋友可以考虑其他材料。\n内衬的定制也没有想象中那么顺利。自然，EVA 裁剪也是面向批发，对于个人定制，大多要求开模，这样也是张口就要一两百： 所幸，最后还是有店家愿意为我手工裁切、粘贴。经交流，为避免开模（否则价格不菲），内衬尺寸改为：\n底：265x185x45 mm，凹槽 200x150x20 mm 盖：265x186x25 mm 店家很耐心，哪怕对面钱少事多。 最后的报价是—— 19.21 + 20 = 39.21，不到 40 元就解决了之前要 240 才能定制的问题！\n结果 尺寸完美合适，一次定制即拿下！再也不用担心心爱的碟子受损啦！\n材料轻盈厚实，虽然确实有点味，在阳台阴凉处放几天就好多了，要鼻子凑到跟前才能闻到（刚到货时，一打开就有一股塑料味直冲脑门）。\n后记 很成功的一次定制。美中不足的是 DIY 的占比几乎没有，喜欢动手的朋友可以买原材料回来自己尝试，在此抛砖引玉了。\n","permalink":"https://blog.allenwu233.com/zh/posts/cd-box/","summary":"车万碟佬的日常","title":"记一次CD保护盒定制"},{"content":"正文 睡不着，爬起来发现今晚的月亮出奇地亮，能照出人影。空气异常干燥而清澈，满月甚至有点眩目，令点缀在其周围的星辰黯然失色，有如永夜抄的虚假之月。\n终于理解古人为何如此执着于“月“这一意象：\u0026ldquo;今人不见古时月，今月曾经照古人。古人今人若流水，共看明月皆如此。\u0026rdquo;\n真的很迷人呀。\n——2025.04.16 凌晨二时\n","permalink":"https://blog.allenwu233.com/zh/posts/moon-walking/","summary":"大晚上的诗兴大发","title":"月色入户，欣然起行"},{"content":"正文 今天是感冒的第三天。本来是风热感冒，仅仅咽喉肿痛。现在开始有痰、流清鼻涕，出现风寒症状，咽喉痛反而没那么引人注意了。寒热交织的感觉有点奇妙，风热为主，并不头晕头痛，精神状态良好。果然是作的，前些天吃过煎炒的饭菜，长跑后的一小时之后洗冷水澡，再加上流感，而且天气异常干燥，一下子就生病了。好在症状很轻，权当激活免疫力了，也是好事。欲速则不达，本来洗冷水澡是为了锻炼身体，下次还是选非跑步日洗冷水澡罢。\n感冒时对维生素 C 的渴求异常旺盛——平时稍显酸涩的柑橘，现在吃起来是格外酸甜——原来身体对某种营养的需求是这样体现出来的，有意思。电解质水也是，为长跑准备的宝矿力冲剂也派上用场了。\n结果下午感觉风寒开始占上风了，清鼻涕流水般止不住地渗，微微畏寒。舌苔一半黄一半白，舌尖甚至发红，红得要滴出血来。\n等好了，打算还跑步，也还洗冷水澡，只是顺着点来。不是不可以洗冷水澡，只是别在身体已经累了的时候再加一把劲。生活和身体，其实都讲个“宽”。小病一场，剥一个橘子，觉得日子也不坏。\n","permalink":"https://blog.allenwu233.com/zh/posts/peel-an-orange/","summary":"小病一场，剥一个橘子，觉得日子也不坏","title":"剥一个橘子"},{"content":"事出有因 诈尸刚好一年了\n前段时间因为 SSL 证书过期，博客挂了大半年，但是太忙而把这事给忘了。才不是懒呢（心虚）\n后来三番五次想换新博客主题，折腾了好几次都没出结果。这次一口气换上了轻微调教过的PaperMod主题，效果还算满意\n重审博文 越来越感觉以前写的东西像黑历史了。内容过水，大多是不知所谓的配置教程 （不如直接去看Arch Wiki)，还有东拼西凑出来的学习笔记，缺少个人的见解与思考\n痛定思痛，删掉低质内容，重整门面，争取写出更优质的文章（\n","permalink":"https://blog.allenwu233.com/zh/posts/hugo-papermod/","summary":"时隔一年的回归","title":"再度折腾博客"},{"content":"引言 无法忍受日渐卡顿和GPS定位出问题的Honor Play，我换上了Redmi Note 12 Turbo，而前者也终于结束了它将近五年的服役\n正是看中了 易刷机 和 性价比高 的特点，我才选了这款手机。于是，搁置多年的玩（折）机（腾）之旅又将继续（\n自然得玩玩类原生系统了。我选择刷入LineageOS，已经有大佬上传了非官方的ROM，非常方便\n刷机 解锁Bootloader 可以看看这篇教程1\n绑定小米账号 一般新机需要绑定小米账号并插入SIM卡 168小时（一周） 后才能解锁Bootloader。绑定步骤如下：\n一、开启 开发者选项：1.我的设备 – 2.全部参数 – 3.连击MIUI版本 二、1.更多设置 – 2.开发者选项 – 3.设备解锁状态 – 4.绑定账号和设备（需要插入SIM卡） 等待一周后进入下一步 解锁BL 这一步最好是在Windows系统下完成，虚拟机或wine可能会出现问题\n去小米官网下载解锁软件， 解压后运行 MiUsbDriver.exe ，登录后连接手机，按提示进入Fastboot模式（关机状态下按电源键+音量下键）操作即可\n刷入LineageOS 建议优先参考ROM提供者的教程2\n下载 下载此页面中除lineage-21.0-20240306-UNOFFICIAL-marble.zip.sha256sum外的所有文件，即：\n*-marble-boot.img *-marble-dtbo.img *-marble-recover.img *-marble-vendor_boot.img *-marble.zip 刷入 需要有基本的fastboot和adb相关知识\n在Arch Linux下安装fastboot和adb：\nparu -S android-tools 将手机连接到PC，手机进入fastboot模式，然后依次刷入下面四个img：\nfastboot flash boot \u0026lt;boot\u0026gt;.img fastboot flash dtbo \u0026lt;dtbo\u0026gt;.img fastboot flash vendor_boot \u0026lt;vendor_boot\u0026gt;.img fastboot flash recovery \u0026lt;recovery_filename\u0026gt;.img 这里的\u0026lt;boot\u0026gt;.img代表你所下载的 *-marble-boot.img，其他几个同理\n重启到recovery模式。可以用命令：\nfastboot reboot recovery 也可以关机状态按电源键+音量上键进入\n在recovery界面按： Factory Reset - Format data / factory reset 以格式化\n返回主菜单，按 Apply Update - Apply from ADB\n在PC上运行命令以刷入LineageOS：\nadb sideload \u0026lt;filename\u0026gt;.zip 根据ROM提供者的提示，PC终端上显示安装进度可能会卡在47%，然而手机提示已完成安装，是否需要安装额外的包。不用担心，其实系统已经成功安装了，此时点 No，然后重启到正常的系统即可\nTip: Normally, adb will report Total xfer: 1.00x, but in some cases, even if the process succeeds the output will stop at 47% and report adb: failed to read command: Success. In some cases it will report adb: failed to read command: No error or adb: failed to read command: Undefined error: 0 which is also fine.\n以后更新系统直接在recovery刷入ROM即可\n⚠️ 第一次进系统时建议先不要插入SIM卡，以免出现奇奇怪怪的问题\nRoot 折腾手机自然少不了Root啦。我使用的是安装过程简便的Magisk\n安装Magisk 推荐阅读3\n先在手机上安装Magisk app， 然后将前面下载的\u0026lt;boot\u0026gt;.img拷到手机上，打开Magisk， 安装 - 选择并修补一个文件， 选中刚刚拷的文件，修补后拷回电脑\n手机上允许adb调试。重启到fastboot模式并刷入修补后的镜像：\nadb reboot fastboot fastboot flash boot \u0026lt;magisk_patch-filename\u0026gt;.img 重启，尽享root后的世界吧！\n更新系统后Magisk会失效，可以重新执行此步骤修补镜像并刷入\n安装Magisk modules 先在Magisk的设置里开启Zygisk\n推荐几个好用的模块：\nModule Name Description AdGuardHome 屏蔽大多数应用的广告，强烈安利 Sui 使Magisk管理应用的逻辑更现代化，依赖Zygisk Shamiko4 向应用隐藏Root，强烈安利 LSPosed 类似Xposed框架，可安装许多插件 uperf 用户态性能控制器，实现大部分内核态升频功能。可配合子模块SfAnalysis和SsAnalysis FingerprintPay 让微信、QQ、支付宝、淘宝、云闪付支持使用指纹支付 安装方式：模块 - 从本地安装 安装成功后重启即可\nApps推荐 App Name Description F-Droid 自由开源软件下载 Aurora Store Google Play的非官方自由/开源软件客户端 冰箱 Ice Box 把暂时不用或者不需常驻后台的应用“冻结”起来 Scene 一个集高级重启、应用安装自动点击、CPU调频等多项功能于一体的工具箱 已知问题 重启后无法接收短信 可能是LineageOS的问题。根据用户aqwgtj的回复，在设置里面禁用再启用SIM卡就能正常接收短信了： 设置 - 网络和互联网 - SIM卡 - \u0026lt;选择SIM卡\u0026gt; - 重新开关使用SIM卡\naqwgtj: make sure to SMS normal must be to disable your SIM and re-enable it after restarting machine eachtime, either no SMS can see.\n目前还没有找到根治的办法，只好每次重启都重开一次😕\n2024-04-02 更新\nROM提供者已提供更新，优化UI的同时还修复了SMS的问题，添加老化保护（burn-in protection），并重新加入充电控制功能\nhttps://xdaforums.com/t/rom-14-unofficial-lineageos-21-for-xiaomi-poco-f5-redmi-note-12-turbo.4655286/post-89434291\n更新 更新系统。直接通过adb线刷完整系统包即可，但是Magisk的修复就要注意了。起初我不假思索的刷入之前magisk修复的包，结果直接进不了系统……\n正确姿势 使用payload-dumper-go提取新版本系统包的boot.img，再在Magisk里修补镜像，重新刷入修补后的镜像\n安装payload-dumper-go-bin\nparu -S payload-dumper-go-bin 解压系统包，要用到的是payload.bin\nunzip \u0026lt;system_package\u0026gt;.zip payload.bin 提取boot.img\npayload-dumper-go -p boot payload.bin 通过fastboot刷入经Magisk修补后的镜像即可\nfastboot flash boot boot.img 关于Zygisk 重刷后关闭所有zygisk模块，重启，然后再启用zygisk模块，再重启\n附录 小米手机解锁Bootloader（Xiaomi手机解BL锁）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n[ROM][14][UNOFFICIAL] LineageOS 21 for Xiaomi POCO F5 / Redmi Note 12 Turbo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMagisk安装教程\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nShamiko安装（Shamiko install）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.allenwu233.com/zh/posts/redmi-note-12-trubo-flash/","summary":"生命在于折腾","title":"红米Note 12 Turbo刷机小记"},{"content":"原题 题目描述 You are given a graph with $n$ vertices and $m$ undirected edges of length $1$. You can do the following operation on the graph for arbitrary times:\nChoose an edge $(u,v)$ and replace it by two edges, $(u,w)$ and $(w,v)$, where $w$ is a newly inserted vertex. Both of the two edges are of length $1$.\nYou need to find out the maximum number of vertices whose minimum distance to vertex $1$ is no more than $k$.\n输入描述 The first line contains three integers $n (1≤n≤10^5)$, $m (0≤m≤2⋅10^5)$ and $k (0≤k≤10^9)$. Each of the next $m$ lines contains two integers $u$ and $v (1≤u,v≤n)$, indicating an edge between $u$ and $v$. It is guaranteed that there are no self-loops or multiple edges.\n输出描述 Output an integer indicating the maximum number of vertices whose minimum distance to vertex $1$ is no more than $k$.\n示例1 输入\n5 4 2 1 2 2 3 3 1 4 5 输出\n5 示例2 输入\n8 9 3 1 2 1 3 1 5 3 4 3 6 4 5 5 6 6 7 7 8 输出\n15 示例3 输入\n114 0 514 输出\n1 备注: Here is the illustration for the second example.\n题意 给出一个边长为$ 1 $的无向图，其中每条边都可以插入数量任意的结点。求到结点$1$距离不大于$k$的结点数的最大值\n分析 以样例2为例：\n显然，对于度数为1的结点（如结点2），可以在它和与其相关联的点之间插入任意个结点，而不影响其他的点。即：度数为1的结点所在的边最多贡献$k$个结点\n先从 $1$ 开始 BFS，同时求出每个点到 $1$ 的最短路\n画出BFS树，并标出各点的度数\n考虑选什么边来加点，两种情况：\n第一种，删除该边不影响任何一个点到 $1$ 的最短距离。若一个点到 $1$ 的最短距离小于等于 $k$ 且该点度数大于等于 $2$，则存在 度数 - $2$ 条这样的边（如 $(3,4)$、 $(4,5)$、 $(5,6)$，这三条边分别可提供$2$、$2$、$1$ 个贡献）\n第二种，删除该边影响某点到 $1$ 的最短路，那么这样的整个分支最多为答案提供 $k$ 的贡献（如 $(1,2)$ ）\n于是先假设所有与结点 $1$ 相关联的点都为第二种点，然后再选边加点\n可用链式前向星存图\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define _all(x) (x).begin(), (x).end() #define _abs(x) ((x \u0026gt;= 0) ? (x) : -(x)) #define PII pair\u0026lt;int, int\u0026gt; #define PLL pair\u0026lt;LL, LL\u0026gt; #define PDD pair\u0026lt;double, double\u0026gt; #define fi first #define se second typedef long long LL; typedef long double LD; typedef unsigned long long ULL; const int INF = 0x3f3f3f3f; const LL LINF = 0x3f3f3f3f3f3f3f3f; const double PI = acos(-1.0); using namespace std; const int N = 1e5 + 10; const int M = 2e5 + 20; int n, m, k, idx; int h[N], to[M*2], ne[M*2], d[N], dis[N]; // d[] 度数 void add(int u, int v) { to[idx] = v, ne[idx] = h[u], h[u] = idx++; } void init() { memset(h, -1, sizeof(h)); memset(dis, -1, sizeof(dis)); dis[1] = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v); add(v, u); d[u]++; d[v]++; } } void bfs() { queue\u0026lt;int\u0026gt; q; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = ne[i]) { // ~i 等价于 i != -1 int v = to[i]; if (dis[v] == -1) { dis[v] = dis[t] + 1; q.push(v); } } } } void solve() { bfs(); LL ans = 1 + d[1] * k; // 记得加上结点 1 本身 // 选边加点 for (int i = 2; i \u0026lt;= n; i++) { if (~dis[i] \u0026amp;\u0026amp; d[i] \u0026gt;= 2 \u0026amp;\u0026amp; dis[i] \u0026lt; k) { ans += (LL)(k - dis[i]) * (LL)(d[i] - 2); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { IOS init(); solve(); return 0; } 附录 参考文献 https://ac.nowcoder.com/acm/discuss/blogs?tagId=253614\n版权信息 本文原载于https://blog.allenwu233.com/，复制请保留原文出处\n","permalink":"https://blog.allenwu233.com/zh/posts/nowcoder-k-subdivision/","summary":"\u003ch2 id=\"原题\"\u003e原题\u003c/h2\u003e\n\u003ch3 id=\"题目描述\"\u003e题目描述\u003c/h3\u003e\n\u003cp\u003eYou are given a graph with $n$ vertices and $m$ undirected edges of length $1$. You can do the following operation on the graph for arbitrary times:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eChoose an edge $(u,v)$ and replace it by two edges, $(u,w)$ and $(w,v)$, where $w$ is a newly inserted vertex. Both of the two edges are of length $1$.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYou need to find out the maximum number of vertices whose minimum distance to vertex $1$ is no more than $k$.\u003c/p\u003e","title":"“范式杯”2023牛客暑期多校训练营1 K - Subdivision"},{"content":"正文 By 尼古拉斯·八重嘤\n“仪式感”这个词对各位而言绝不陌生，它可以体现在一顿饭前的“我开动啦”，可以体现在考试后没挂科吃顿小烧烤的庆祝，也可以体现在生日小蛋糕上插的一根蜡烛……这都是仪式感的体现。但我相信，生活毫无仪式感的人也不在少数，我也是其中之一。\n我先亮明一下立场，无仪式感并不是带有贬义的形容词，本身这个词语就是中性词，带有过多的偏见去看待是不理智的。无用的话我也不会多说，直接过渡到正文。\n我的无仪式感生活是怎么样的？记得自己的生日，但如果别人不主动，自己其实不庆祝也毫无关系，不会发朋友圈发动态，依然保持原有的生活作息；过年完全没有节日感，如果家中的长辈不张罗年夜饭的准备，吃外卖煮泡面也完全能够接受，只不过是个长一些的假期；对于自身取得的成就，无论大小，完全无感，并没有想要庆祝的想法，比如高考考上了985,只是像喝水吃饭一样稀松平常，不会有过多的情绪波动。\n说到这里，没错，鲜有情绪波动既是无仪式感的体现，也是其原因，生活中可能会有太多的事分散了自己的感情，比如繁重的课业，琐碎的工作，复杂的人际关系，都会消耗我们自身的情绪，导致人长期处于一种“burn out”的状态，看似不以物喜，不以己悲，实则情绪枯竭，无力反应。\n节日和生日的意义不在于有多么大的排场，多么奢侈的体验，在于为自己找一个时间，找一个理由去享受生活，给自己的身体和心灵都放一个假。也就是说，其本质并不是不可或缺，如果一个人在普普通通的日子里也有自己寻找快乐的理由和时间，平凡的世界也不缺少独属于自己的节日。\n人最大的悲哀莫过于“向之所欣，俯仰之间，已为陈迹”，任何快乐都是有保质期的，而“仪式感”的存在更像是提醒我们去关注这些快乐，去享受这些快乐，不要活得像个苦行僧，自我折磨却安慰自己说这是天将降大任于斯人。人生得意须尽欢，莫使金樽空对月，花钱有花钱的快乐，不花钱有不花钱的快乐，快乐的意义在于给人带来快乐，忘却暂时的忧愁。“我没钱”和“我没时间”从来不是拒绝感受快乐的借口，读一本书可以感到快乐，思考哲学可以感到快乐，看个相声可以感到快乐，吃顿好的也可以感到快乐。\n人生短暂，不过百年，快乐与痛苦交织的生活是这世界上大多数人的主旋律，没有痛苦的快乐不是快乐，没有快乐的痛苦也不是痛苦。每个人都有身体的桎梏，但心灵的束缚却不是外人所能控制的，“因寄所托，放浪形骸之外”的乐趣未尝不可寻得。\n祝好，回见。\n夹带私货 ","permalink":"https://blog.allenwu233.com/zh/posts/ritual-sense-of-life/","summary":"人生得意须尽欢，莫使金樽空对月","title":"为什么有些人需要生活的仪式感？"},{"content":"正式拥有了属于自己的域名！\n有了域名后，博客的曝光率也会大一些了罢（大嘘）\nAnyway，在我的博客生涯中，这确实可以算是个有意义的节点\n于是\u0026hellip;\u0026hellip;\nWorld, hello fn greet_world() { let southern_germany = \u0026#34;Grüß Gott!\u0026#34;; let chinese = \u0026#34;世界，你好\u0026#34;; let english = \u0026#34;World, hello\u0026#34;; let japanese = \u0026#34;世界よ、こんにちは\u0026#34;; let regions = [southern_germany, chinese, english, japanese]; for region in regions.iter() { println!(\u0026#34;{}\u0026#34;, \u0026amp;region); } } fn main() { greet_world(); } 灵感来自：不仅仅是 Hello world\n","permalink":"https://blog.allenwu233.com/zh/posts/worldhello/","summary":"不仅仅是 Hello world","title":"World, Hello!"},{"content":"2022.12.11 - 2023.05.17 嘛，就像是一场梦。\n新生赛侥幸第六进入集训队的欣喜、codeforces的下马威、寒假牛客训练营的坐牢、下午的uva刷题、集训的或是集体坐牢或是轮流A题、div.3个人最好记录的自得、2023 GDCPC SZUT的两日游（隔音奇差、每隔一个小时就被吵醒一次的屑酒店，GDCPC的打铁）\u0026hellip;\u0026hellip;\n竞赛这条路还是不太适合我啊（笑）\n后记（？） 没有什么遗憾~~（flag，快进到后知后觉）~~，不过心情也是有一丝复杂。至少，我也在ACM的大门前往里看了几眼，仰望过高峰 _(:з」∠)_\n年仅半年的ACMer生涯，堂堂完结！\n复！活！ TNND，真是被看扁了呀！ 爱的力量，是无限的！（筋肉魔理沙.jpg）\n嘛，大概是一时脑抽了——毕竟长时间的高压训练和GDCPC的出师不利也挺打击学习的热情的。不过，现在我的看法是：\n只要我在无数次的 WA, TLE 后的 AC 仍能欣喜若狂，我就能打ACM.\nACMer 生涯，堂堂连载！\n2023.05.18\u0026ndash;\nACM生涯，堂堂休刊！ 看到已经到了旅途的终点了。\n一年的 ACMer 生涯，说长不长，说短不短——有欢笑，有泪水；有成功，有失败；有喜悦，有失望……牺牲了几乎所有的课余时间，换来的是什么呢？\n是了，队友——两位很好的队友，即便训练再苦再累、比赛再坐牢，仍能相互鼓励、笑对挑战——但我感觉自己亏欠了他们，因为是我首先提出离队的，在这里向他们道谢，谢谢一直以来的关心和宽容。\n其次是算法能力和抗压能力。长期的算法学习，使我面对算法题时，哪怕是从未见过的题型，也能给出大致方向，编程能力更是完全不虚；另一方面，~~毕竟都见过 XCPC 这种大场面 XD，~~面对压力场景，也能游刃有余。\n追风赶月莫停留，平芜尽处是春山。\n\u0026ndash;2023.09.17\n","permalink":"https://blog.allenwu233.com/zh/posts/end-of-my-acm/","summary":"实迷途其未远，觉今是而昨非","title":"ACM生涯，堂堂完结！（？）"},{"content":"前言 题目链接：Codeforces Round 867 (Div. 3)\n入坑以来打的最好的一次。特写此题解，记录一下心得\nA 题为完整代码，其他题目只有核心代码（省略了模板）\n正文 A. TubeTube Feed 题意：给出数组a[]（代表视频长度，单位：s）和b[]（代表视频的“entertainment value”，我们用变量fun来存储其最大值），整数t（午餐时长）。对于一个视频，可以跳过（消耗1s）,也可以决定就看这个视频，但要保证消耗的时间和视频时长之和不超过t。求选择观看哪一个视频（求出a[]的下标），使得fun最大\n根据题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define _all(x) (x).begin(), (x).end() #define _abs(x) ((x \u0026gt;= 0) ? (x) : (-x)) #define PII pair\u0026lt;int, int\u0026gt; #define PLL pair\u0026lt;LL, LL\u0026gt; #define PDD pair\u0026lt;double, double\u0026gt; #define fi first #define se second typedef long long LL; typedef long double LD; typedef unsigned long long ULL; const int INF = 0x3f3f3f3f; const double PI = acos(-1.0); using namespace std; const int N = 50 + 5; int n, t, a[N], b[N]; void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i]; } void solve() { int ans = -1, fun = -1; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] \u0026lt;= t) if (fun \u0026lt; b[i]) { ans = i; fun = b[i]; } t--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { IOS int test_case; cin \u0026gt;\u0026gt; test_case; while (test_case--) { init(); solve(); } return 0; } B. Karina and Array 题意：给出一个数组，找到两个数，使得这两个数的积最大\n排序，比较 最大数与次大数之积、最小数与次小数之积的大小即可\n注意中间变量要用long long存储\nconst int N = 2e5 + 20; int n, a[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); cout \u0026lt;\u0026lt; max(((LL)a[0] * (LL)a[1]), ((LL)a[n-1] * (LL)a[n-2])) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } C. Bun Lover 题意：两个面包卷以螺旋状盘成一个边长为$ n $正方形（蚊香？），每个面包卷的内外都涂有巧克力酱。给出任意的 $ n $ ，求巧克力酱线段的总长\n容易找到规律： $ ans = 4n + (n - 1) + 2(n - 2) + 2(n - 3) + \u0026hellip; + 2 \\times 2 + 1 \\times 3 = 5n + \\frac{(1+n-2)(n-2)}{2} \\times 2 = n^2 + 2n + 2 $\nLL n; void solve() { cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; n*n + 2*n + 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } D. Super-Permutation 题意：构造一个n排列，使得其前缀和数组各元素 $ (\\mod n\\ ) + 1 $ 后也是一个n排列\n构造题。容易看出前缀和数组各元素模上n后为0 ~ n-1，根据模运算的性质： $ (a+b) \\mod n = a \\mod n + b \\mod n $ 我们可以直接对取模后的余数进行加法操作\n以$ n = 6$为例。构造出6 5 2 3 4 1，其余数数组为0 5 2 3 4 1，则前缀和模n数组为0 5 1 4 2 3 比较一下构造出来的数列和前缀和数组模n:\n6 5 2 3 4 1 0 5 1 4 2 3 发现规律了吗？\n对于任意的n，两个两个地构造前缀和模n数组：\nb = [0, n-1, 1, n-2, 2, n-3, ......] 即可。不过我们不需要构造出这个数组再来构造n排列，直接计算就行（具体细节参考代码）\n关于正确性的分析 先来构造前缀和模n数组。首先考虑0。0必须放在首位，否则会出现两个相同的元素\n其次，n为奇数一定无解，反之一定有解。\n对于该数组，$ sum = \\frac{(1 + n)n}{2} $，令 $ k = \\frac{1 + n}{2} $ ，则 $ sum = kn $\n当 $ n $ 为奇数时，$ k $为整数，则 $ sum \\mod n = 0 $ ，与已存在的 0 相矛盾\n当 $ n $ 为偶数时，$ k $不为整数，且 $ sum \\mod n = \\frac{n}{2} $ ，不存在矛盾\n代码 int n; void solve() { cin \u0026gt;\u0026gt; n; if (n == 1) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } if ((n \u0026amp; 1) == 1) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n-1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (int i = 1; i \u0026lt; n / 2; i++) { cout \u0026lt;\u0026lt; i*2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n - i*2 - 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } E. Making Anti-Palindromes F. Gardening Friends G1. Magic Triples (Easy Version) G2. Magic Triples (Hard Version) (To be continued\u0026hellip;)\n","permalink":"https://blog.allenwu233.com/zh/posts/contest-1822/","summary":"第一篇CF题解","title":"Codeforces Round 867 (Div. 3) 题解"},{"content":" 来点BGM\n引言 概念 动态规划（英语：Dynamic programming，简称DP） 是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。\n适用情况 最优子结构性质。 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。\n无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。\n子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。\n——From 维基百科·动态规划\n动态规划其实不是一种具体的算法，而是解决问题的思想和方法。简单来说，动态规划就是把问题分解成一个个子问题，通过求子问题的最优解得到全局最优解（这就是所谓的最优子结构（optimal substructure））\n正文 状态和状态转移方程 动态规划的核心是状态和状态转移方程\n动态规划中状态就是子问题的结果，而本阶段的状态往往是上一阶段状态和上一阶段决策的结果，描述这种前后阶段关系的方程，就是状态转移方程\n如 $ f(i, j) = \\max \\{f(i, k) , f(k+1, j)+1\\} $ 就是一个状态转移方程\n来看看几道例题\n数字三角形 题目：有一个由非负整数组成的三角形，第一行只有一个数。从第一行的数开始，每次可以往左下或右下走一格，直到走到最下行，把沿途经过的数加起来，求怎么走才能使得数字之和最大？\n数字三角形如下所示：\n1 / \\ 3 2 / \\ / \\ 4 10 1 / \\ / \\ / \\ 4 3 2 20 分析 贪心法？ 按照贪心法，求出的路径为：1 --\u0026gt; 3 --\u0026gt; 10 --\u0026gt; 3\n而实际最大和的路径为：1 --\u0026gt; 2 --\u0026gt; 1 --\u0026gt; 20\n显然，贪心法不能保证全局最优解\n回溯法？ 每一个结点都有两种选择，如果用回溯法求出所有可能的的路径，就能找到最优解\n然而回溯法的效率太低：一个$ n $层的三角形有 $ 2^{n-1} $ 条路线，复杂度之大让人无法接受\n可以看出，这是一个动态的决策问题——每次可以选择往左下走或往右下走，由此引出我们今天的主角——动态规划\n动态规划 假设用下三角矩阵（主对角线上方所有元素为0的二维数组）a、d分别存储数字三角形和d[i][j]出发路径的最大和\n根据动态规划的思想，求第一层（d[1][1]，即整个数字三角形路径的最大和）出发的最大和，得先求出从第二层出发的最大和；求第二层出发的最大和，得先求出从第三层出发的最大和\u0026hellip;\u0026hellip;由此类推，我们可以把整个问题分解成多个子问题。显然，这道题符合动态规划的条件：\n最优子结构性质。求出第n层的最优解，就能求出第n-1层的最优解，子问题的最优解最终保证整个问题的最优解 无后效性。第n层的最优解一旦确定，就不受前面层的影响 子问题重叠性质。比如要计算d[2][1],就要先计算d[3][1]和d[3][2]；而要计算d[2][2],也要先计算d[3][2]。由此可见问题的解答树大量重叠，正是动态规划的用武之地 状态转移方程如下\n$ d(i, j) = a(i, j) + max\\{d(i+1, j), d(i+1, j+1)\\} $\n下面介绍两种基本的动态规划写法\n方法一：记忆化搜索 直接递归的写法是可以的，但由于子问题的重叠，会导致大量无用的重复计算，因此要用到记忆化搜索来提前返回\n核心代码如下\n// 因为题目说每个数都是非负整数，所以d[]初始化为-1，d[i] \u0026gt;= 0 表示未计算 int solve(int i, int j) { if (d[i][j] \u0026gt;= 0) return d[i][j]; // 已经搜索过，直接返回 return d[i][j] = a[i][j] + (i == n ? 0 : max(solve(i+1, j), solve(i+1, j+1))); // 保存计算结果的同时并返回值 } 这里利用了C语言“赋值语句具有返回值”的特性来简化代码\n方法二：递推 注意计算顺序，要从后往前推\n核心代码如下\nvoid solve() { for (int i = 1; i \u0026lt;= n; i++) d[n][i] = a[n][i]; // 初始化最后一层 for (int i = n-1; i \u0026gt;= 1; i--) // 从后往前递推 for (int j = 1; j \u0026lt;= i; j++) d[i][j] = a[i][j] + max(d[i+1][j], d[i+1][j+1]); cout \u0026lt;\u0026lt; d[1][1] \u0026lt;\u0026lt; endl; } 完整代码可参考仓库（附赠数据生成器Python脚本）\nDAG上的动态规划 跟图论扯上关系了（￣▽￣）\n相关笔记：Allen的图论基础\nDAG（Directed Acyclic Graph，有向无环图），即从任意顶点出发无法经过若干条边回到该点的有向图。\n不固定终点的最长路和字典序 例题：嵌套矩形。 题意：给出若干个矩形，选出尽量多的矩形拍成一排，使得除了最后一个之外，每一个矩形都可以嵌套（矩形的长和宽必须严格小于下一个矩形的长和宽；矩形可以旋转）在下一个矩形内。如果有多解，矩形编号的字典序应尽量小\n可以看出，“嵌套”是一个二元关系，可以用图来表示。我们使用邻接矩阵来存图\n状态转移方程为：$ d(i) = max\\{d(i), d(j)+1\\} $\n代码如下：\n#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100 + 10; int n; int G[N][N], a[N], b[N], d[N]; // d[i] 表示从结点 i 出发的最长路长度 // 读入数据并建图 void read_input() { cin \u0026gt;\u0026gt; n; int x, y; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; a[i] = min(x, y); b[i] = max(x, y); } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (a[i] \u0026lt; a[j] \u0026amp;\u0026amp; b[i] \u0026lt; b[j]) G[i][j] = 1; } // 记忆化搜索，注意 d[] 要初始化为0 int dp(int i) { int \u0026amp;ans = d[i]; // 用引用来简化读写 if (ans \u0026gt; 0) return ans; ans = 1; for (int j = 1; j \u0026lt;= n; j++) if (G[i][j]) ans = max(ans, dp(j)+1); return ans; } // 递归打印答案，保证字典序最小：尽量选择最小的 i 和 j void print_ans(int i) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (int j = 1; j \u0026lt;= n; j++) if (G[i][j] \u0026amp;\u0026amp; d[i] == d[j]+1) { print_ans(j); break; // 递归返回后退出循环 } } int main() { #ifdef LOCAL freopen(\u0026#34;nested_rectangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;nested_rectangle_.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int t; cin \u0026gt;\u0026gt; t; while (t--) { memset(d, 0, sizeof(d)); memset(G, 0, sizeof(G)); read_input(); for (int i = 1; i \u0026lt;= n; i++) dp(i); int Max = -1, maxi = 1; for (int i = 1; i \u0026lt;= n; i++) if (d[i] \u0026gt; Max) { Max = d[i]; maxi = i; } print_ans(maxi); cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; } return 0; } EX: UVa 437 The Tower of Babylon\n例题的升级版，只是多了一个维度，完全可以套用例题的模板\nAC代码参考\n固定终点的最长路和最短路 例题：硬币问题。 有 n 种硬币，面值分别为 V1, V2, \u0026hellip; , Vn, 每种都有无限多。\nEX: Uva 1347 Tour\n原题可转化为：两人从同一起点出发，每次其中一人走动，最后都走到终点\nAC代码参考\n附录 参考文献 [1]维基百科·动态规划\n[2]刘汝佳《算法竞赛入门基础（第2版）》\n","permalink":"https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/","summary":"状态和状态转移方程","title":"Allen的动态规划基础"},{"content":"引言 什么是图论？ 图论是离散数学的一个十分有趣的分支，以 “图” 为主要研究对象，研究图的内在结构，探索其中的组合性质、代数性质和拓扑性质，找到满足条件的“好图”等。比如大名鼎鼎的七桥问题（欧拉回路）就属于图论的范畴\n那么，图又是什么呢？ 简单来说，图（Graph） 是由多个点以及连接这些点的线所构成的对象。具体定义详见维基百科·图、OI Wiki·图论相关概念\n在计算机中，图也是一种相当重要的数据结构，最短路、最小生成树、网络流等问题往往需要图来实现\n图的存储 本文约定用 $ n $ 代指图的点数，用 $ m $ 代指图的边数，用 $ d^+(u) $ 代指点 $ u $ 的出度，即以 $ u $ 为出发点的边数\n邻接矩阵 方法 从图的概念我们知道，图由点集和边集组成。而我们可以用一个二维数组G来存边，G[u][v] = 1表示存在从u到v的边。如果边带权值w，可以令G[u][v] = w\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int maxn = 1000; int n, m; bool vis[maxn]; int G[maxn][maxn]; // 查找边(u,v)是否存在 bool find_edge(int u, int v) { return G[u][v]; } void dfs(int u) { if (vis[u]) return; vis[u] = true; cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (int v = 1; v \u0026lt;= n; v++) if (G[u][v]) dfs(v); } int main() { // 一共有n个点,m条边 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; G[u][v] = w; } cout \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) { memset(vis, false, sizeof(vis)); dfs(i); cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; find_edge(3, 1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; find_edge(4, 5) \u0026lt;\u0026lt; endl; return 0; } /* 输入示例： 5 6 1 2 1 2 3 2 1 3 3 3 1 10 3 4 3 5 2 7 */ 例题：P1359 租用游艇\n利用邻接矩阵来存储图，注意在本题中邻接矩阵为半矩阵（类似于上三角矩阵，但主对角线元素为0， 即a[i][i] = 0）。需要注意的是，单纯dfs会超时，需要剪枝\n动态规划也可以解，而且代码非常简洁（貌似本来是就动态规划的题，被我硬生生写成dfs😂）\n复杂度 查询是否存在某条边：$ O(1) $\n遍历一个点的所有出边：$ O(n) $\n遍历整张图：$ O(n^2) $\n空间复杂度：$ O(n^2) $\n应用 邻接矩阵只适用于没有重边（或重边可以忽略）的情况\n其最显著的优点是可以$ O(1) $查询一条边是否存在\n由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵\n（以上关于复杂度和应用的资料来源于OI Wiki·图的存储，下同）\n邻接表 方法 我们可以为各个点分别存储与它相关联的边，如：\n1: --\u0026gt;a --\u0026gt;b --\u0026gt;c 2: --\u0026gt;b --\u0026gt;c 3: --\u0026gt;c --\u0026gt;d --\u0026gt;e 4: --\u0026gt;a --\u0026gt;d 可以看出邻接表是一种链表，它是以任意顺序来存储边的。但在算法竞赛中，我们可以用数组或vector来模拟链表\n我们也可以存储边的终点，比如下图：\n1: [2, 3, 5] 2: [5] 3: [1] 4: [3] 5: [] 如果是无向边，只需两个端点都存一遍即可，比如无向边(1, 2):\n1: [2] 2: [1] 下面是C++代码实现：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct Node { int v; // 边的终点 int w; // 边权 }; int n, m; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;Node\u0026gt; \u0026gt; G; // 存储点 u 的所有出边的相关信息（终点、边权等） // 查找边(u,v)是否存在 bool find_edge(int u, int v) { for (int i = 0; i \u0026lt; (int)G[u].size(); i++) if (G[u][i].v == v) return true; return false; } void dfs(int u) { if (vis[u]) return; vis[u] = 1; cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (int i = 0; i \u0026lt; (int)G[u].size(); i++) dfs(G[u][i].v); } int main() { // 一共有n个点,m条边 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vis.resize(n+1, false); G.resize(n+1); for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; G[u].push_back({v, w}); } for (int i = 1; i \u0026lt;= n; i++) { dfs(i); cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; find_edge(1, 2) \u0026lt;\u0026lt; endl; return 0; } 复杂度 查询是否存在 u 到 v 的边：$ O(d^+(u)) $ （如果事先进行了排序就可以使用二分查找做到$ O(\\log(d^+(u))) $ ）\n遍历点 u 的所有出边：$ O(d^+(u)) $\n遍历整张图：$ O(n+m) $\n空间复杂度：$ O(m) $\n应用 存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）\n尤其适用于需要对一个点的所有出边进行排序的场合\n链式前向星 方法 邻接表的升级版，其实就是静态建立的邻接表\n其特点是对边进行编号，第一条边编号为0\n关键是理解一下变量：\n边集数组：e[i]存储第 i 条边的边权 ne，表示与这个边起点相同的上一条边的编号 头结点数组：h[i]表示以 i 为起点的最后一条边的编号 h数组一般初始化为-1，遍历图时ne = -1做为终止条件\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m, idx; int h[N], ne[N], to[N], e[N], vis[N]; // h[u]初始值为 -1 void add_edge(int u, int v, int w) { to[idx] = v; // 终点 e[idx] = w; // 边权 ne[idx] = h[u]; // 以 u 为起点的上一条边的编号 h[u] = idx++; // 更新以 u 为起点上一条边的编号 } void dfs(int u) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; vis[u] = true; for (int i = h[u]; ~i; i = ne[i]) { // ~i 相当于 i != -1 if (!vis[to[i]]) dfs(to[i]); } } void print() { // 遍历各点出边终点 for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int j = h[i]; ~j; j = ne[j]) cout \u0026lt;\u0026lt; to[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } int main() { memset(h, -1, sizeof(h)); // 初始化；ne[i] = -1表示到达终点 // 存图 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add_edge(u, v, w); // add_edge(v, u, w); // 无向边 // 输出存储过程 cout\u0026lt;\u0026lt;\u0026#34;to[\u0026#34;\u0026lt;\u0026lt;idx-1\u0026lt;\u0026lt;\u0026#34;] = \u0026#34;\u0026lt;\u0026lt;to[idx-1]\u0026lt;\u0026lt;\u0026#34;; \u0026#34; \u0026lt;\u0026lt;\u0026#34;ne[\u0026#34;\u0026lt;\u0026lt;idx-1\u0026lt;\u0026lt;\u0026#34;] = \u0026#34;\u0026lt;\u0026lt;ne[idx-1]\u0026lt;\u0026lt;\u0026#34;; \u0026#34; \u0026lt;\u0026lt;\u0026#34;h[\u0026#34;\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026#34;] = \u0026#34;\u0026lt;\u0026lt;h[u]\u0026lt;\u0026lt;\u0026#34;;\\n\u0026#34;; } print(); for (int i = 1; i \u0026lt;= n; i++) { memset(vis, 0, sizeof(vis)); dfs(i); } // 输出存储结果 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (int i = 0; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; \u0026#34;h[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; h[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;ne[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; ne[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;to[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; to[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;e[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34;,\\n\u0026#34;; } return 0; } /* 输入示例： 4 3 1 2 5 2 4 10 4 3 15 */ 复杂度 查询是否存在 u 到 v 的边：$ O(d^+(u)) $\n遍历点 u 的所有出边：$ O(d^+(u)) $\n遍历整张图：$ O(n+m) $\n空间复杂度：$ O(m) $\n应用 存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序\n优点是边是带编号的，有时会非常有用，而且如果idx的初始值为奇数，存双向边时i ^ 1即是i的反边（常用于网络流）\n例题 P3916 图的遍历\n这道题的技巧是反向存图，以便反向查找各点所能到达的编号最大的点，即：\ncin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add_edge(v, u); 反向DFS得出结果：\nfor (int i = n; i \u0026gt; 0; i--) if (!vis[i]) dfs(i, i); 最后输出vis[]即可\n图论相关问题 拓扑排序 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，才能称为该图的一个拓扑排序（英语：Topological sorting）：\n序列中包含每个顶点，且每个顶点只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径。 所谓拓扑排序，就是由一个偏序关系得到一个全序关系。通俗来讲，就是要按照一个特定次序来遍历图的所有序号：遍历一个结点前，需保证指向它的所有结点已经遍历。可以看出，只有有向无环图（DAG）才有拓扑序\n我们可以构思出这样一个算法：\nL = [] # 拓扑序 while 存在结点入度为1： 任选一个入度为1的结点u L.append(u) for v in G[u]: v的度数 -= 1 从图中删除u结点 if len(L) == 初始图总结点数： return True # 拓扑序存在 else: return False 比如下图： # 它的拓扑序可以是： 1 2 3 4 5 # 也可以是： 1 3 2 4 5 可以用BFS或DFS来实现拓扑排序。由于只需遍历一遍结点，复杂度相当客观，为$O(V+E)$\nBFS int n, m, _in[N]; // 点数，边数，入度 bool vis[N]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; topo; bool toposort() { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { if (!_in[i]) q.push(i); } while (!q.empty()) { int u = q.front(); q.pop(); topo.emplace_back(u); for (auto \u0026amp;v : G[u]) { _in[v]--; if (!_in[v]) q.push(v); } } return (int)topo.size() == n; } DFS void dfs(int i) { if (!_in[i] \u0026amp;\u0026amp; !vis[i] \u0026amp;\u0026amp; !tmp[i]) { topo.emplace_back(i); vis[i] = true; tmp[i] = true; // 临时标记。如果遍历到已标记结点，说明不是DAG for (auto \u0026amp;j : G[i]) { _in[j]--; dfs(j); } tmp[i] = false; } } bool toposort() { for (int i = 1; i \u0026lt;= n; i++) dfs(i); return ((int)topo.size() == n); } 例题 Codeforces Round 748 (Div. 3) E.Gardener and Tree\n题意:给出一棵无根树，每次操作删除所有叶子结点，问k次操作后还剩几个结点\n类比拓扑排序，每次操作选出度数为1的结点，遍历其终边并使终点度数减1,然后删除这些结点。注意：题目给出的树是无向的，因此不能直接用DFS（比如树为一条单链，DFS会直接从一头遍历到另一头），而BFS会更好写，代码也是类似的，唯一的区别是，要判断删点前其邻接点度数为1的情况（说明邻接点已经在队列里了）\n#include \u0026lt;bits/stdc++.h\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define _all(x) (x).begin(), (x).end() #define _abs(x) ((x \u0026gt;= 0) ? (x) : (-x)) #define PII pair\u0026lt;int, int\u0026gt; #define PLL pair\u0026lt;LL, LL\u0026gt; #define PDD pair\u0026lt;double, double\u0026gt; #define fi first #define se second typedef long long LL; typedef long double LD; typedef unsigned long long ULL; const int INF = 0x3f3f3f3f; const double PI = acos(-1.0); using namespace std; const int N = 4e5 + 10; int d[N], vis[N], n, k; // d[]为结点度数，vis[]为操作次数 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; void init() { memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; G.clear(); G.resize(n+1); for (int i = 0; i \u0026lt; n-1; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].emplace_back(v); G[v].emplace_back(u); d[u]++, d[v]++; } } // 基于BFS的拓扑排序 void solve() { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { if (d[i] == 1) { q.push(i); vis[i] = 1; } } while (!q.empty()) { int u = q.front(); q.pop(); for (auto \u0026amp;v : G[u]) { // 邻接点度数为1,说明其已经在队列内 if (d[v] != 1) { d[v]--; // 删去点u后v度数为1,v入队 if (d[v] == 1) { vis[v] = vis[u] + 1; q.push(v); } } } } int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { if (vis[i] \u0026gt; k) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { IOS int test_case; cin \u0026gt;\u0026gt; test_case; while (test_case--) { init(); solve(); } return 0; } 欧拉道路、欧拉回路 （待填坑……）\n最小生成树 （待填坑……）\n附录 参考文献 [1]维基百科·图论\n[2]OI Wiki·图论相关概念\n[3]OI Wiki·图的存储\n[4]宫崎修一《程序员的数学4：图论入门》\n[5]链式前向星\u0026ndash;最通俗易懂的讲解\n","permalink":"https://blog.allenwu233.com/zh/posts/allen-graph/","summary":"比如\u0026hellip;\u0026hellip;一笔画问题？","title":"Allen的图论基础"},{"content":"题目 玩过华容道吧？或者是Win7自带小挂件的数字滑块游戏？八数码问题就是从这个游戏引申出来的：\n给定编号为1～8的正方形滑块，排成 $ 3 \\times 3 $ ，其中有一个格子留空。每次操作可以把一个与空格相邻滑块移动到空格内。给定初始局面和目标局面（空格用0表示），求最少移动步数，若无法到达目标局面，则输出-1\n分析 可以看出，这也是BFS求最短路。但要注意判重，即避免同一个访问多次，否则会相当浪费时间和空间\n对于本题， 哈希（Hash） 是一种可行而高效的方法。简单来说，就是设计一个函数 $ h(x) $ ，把任意结点$ x $映射到 $ [0, M-1] $ 内的整数即可，其中$ M $根据可用内存大小自选。在理想情况下，只需开一个大小为$ M $的数组就能判重。但有时候不同结点的哈希值可能相同，就需要把哈希值相同的状态组织成链表\n代码 出自紫书\n有几处值得学习的小技巧，比如定义“状态”类型、用两个数组来模拟单向链表、用“引用”简化代码等\neight_nums.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; typedef int State[9]; // 定义“状态”类型 const int MAXSTATE = 1e6; State st[MAXSTATE], goal; // 状态数组。所有状态都保存在这里 int dist[MAXSTATE]; // 距离数组 const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, -1, 1}; const int MAX_HASH_SIZE = 1e6 + 3; int head[MAX_HASH_SIZE], next_[MAXSTATE]; // 模拟单向链表 void init_lookup_table() { // 初始化查找表 memset(head, 0, sizeof(head)); } int myhash(State \u0026amp;s) { // 哈希函数； int v = 0; for (int i = 0; i \u0026lt; 9; i++) v = v * 10 + s[i]; // 把9个数字合成9位数 return v % MAX_HASH_SIZE; // 确保hash函数是不超过hash表的大小的非负整数 } int try_to_insert(int s) { int h = myhash(st[s]); int u = head[h]; // 从表头开始查找链表 while (u) { if (memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0; // 找到了，插入失败 u = next_[u]; // 顺着链表继续找 } next_[s] = head[h]; // 插入到链表中 head[h] = s; return 1; } int bfs() { // BFS，返回目标状态在st数组下标 init_lookup_table(); // 初始化查找表 int front = 1, rear = 2; // 不使用下标0，因为0被看作“不存在” while (front \u0026lt; rear) { State \u0026amp;s = st[front]; // 用“引用”简化代码 if (memcmp(goal, s, sizeof(s)) == 0) return front; // 找到目标状态，成功返回 int z; for (z = 0; z \u0026lt; 9; z++) if (!s[z]) break; // 找“0”的位置 int x = z/3, y = z%3; // 获取行列编号（0~2） for (int d = 0; d \u0026lt; 4; d++) { int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if (newx \u0026gt;= 0 \u0026amp;\u0026amp; newx \u0026lt; 3 \u0026amp;\u0026amp; newy \u0026gt;= 0 \u0026amp;\u0026amp; newy \u0026lt; 3) { // 如果移动合法 State \u0026amp;t = st[rear]; memcpy(\u0026amp;t, \u0026amp;s, sizeof(s)); // 拓展新结点 t[newz] = s[z]; t[z] = s[newz]; dist[rear] = dist[front] + 1; // 更新新结点的距离值 if (try_to_insert(rear)) rear++; // 如果成功插入查找表，修改队尾指针 } } front++; // 拓展完毕后在修改队首指针 } return 0; // 失败 } int main() { #ifdef LOCAL freopen(\u0026#34;eight_nums.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;eight_nums_.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); for (int i = 0; i \u0026lt; 9; i++) cin \u0026gt;\u0026gt; st[1][i]; // 起始状态 for (int i = 0; i \u0026lt; 9; i++) cin \u0026gt;\u0026gt; goal[i]; // 目标状态 int ans = bfs(); // 返回目标状态的下标 if (ans \u0026gt; 0) cout \u0026lt;\u0026lt; dist[ans] \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } 思考 除了哈希外，还有很多方法，比如编码、A*、STL set（效率低，仅作“跳板”）等，等学到了就来试试（\n参考文献 刘汝佳《算法竞赛入门经典（第2版）》 ","permalink":"https://blog.allenwu233.com/zh/posts/8-nums/","summary":"Hash与BFS","title":"路径寻找-八数码问题"},{"content":"引言 暴力搜索法（又称 穷举搜索，在计算机科学中也称生成与测试）是一种“简单粗暴地”处理问题的方法，通过枚举所有的可能并判断是否符合题意，以得出答案\n但有时候直接枚举会带来问题：枚举量过大而存在大量不必要的枚举，导致算法时间复杂度过大（太低效了）。有没有更好的方法呢？\n回溯法（backtracking） 是暴力搜索法的一种，可在递归构造中把搜索和检查有机地结合起来，从而减小枚举量\n让我们通过几道经典的题目来感受一下回溯法的魅力吧～\n八皇后问题 可以说是最经典的题目之一了。甚至常被作为“判断有没有学过回溯法”的依据 （刘老师如是说）\n如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。 八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解。——From 维基百科·八皇后问题\n而我们要解决的，正是推广后的n皇后问题。但为了方便描述，下面的分析还是以八皇后问题为例\n思路一：组合生成 枚举出所有可能的棋局，再来判断是否符合题目要求。\n问题可以转换为：从 $ 8 \\times 8 = 64 $ 个格子里选出 $8$ 个（即组合生成），保证任两个格子都不能处于同一条横行、纵行或斜线上\n根据排列组合，我们知道共有$ C_{64}^{8} = 4.426 \\times 10^9 $种方案，显然是太复杂了。\n思路二：全排列生成 稍加思考，我们可以改进策略：恰好每行每列各选一个格子，保证任两个格子都在同一斜线上。如此转化为全排列生成的问题，方案数降为$ 8! = 40320 $种，肉眼可见的效率提升啊（笑）\n我们可以用C[x]表示第x行皇后的列编号。难点之一是如何判断皇后间是否斜向攻击。\n把棋盘看作一个以左上角为原点、往下为x轴、往右为y轴的平面直角坐标系，于是棋盘的主对角线就是 $ y = x $ ，于是对于格子$ (x,y) $， $ y-x $ 的值就标识了主对角线（确保你理解了这一点！）。同理，副对角线为 $ y = -x $ ， $ x+y $ 的值标记了副对角线。如下图所示：\n回溯法 接下来，就要用到回溯法了：\n所谓回溯（backtracking），就是指在递归求解问题时，如果当前步骤没有合法选择，则函数返回上一级递归调用\n简单来说，就是把问题分成若干个步骤递归求解，当某一步不合题意时停止，返回上一步。这样可以大大减少运算量\n来看看代码吧～\n普通回溯法 nqueens_1.cpp\n// n皇后问题：在n*n棋盘上放置n个皇后，使得它们互不攻击，找出所有解 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int C[50], tot = 0, n = 8, nc = 0; // C[x]表示第x行皇后的列编号 void search(int cur) { nc++; // 递归次数 if (cur == n) tot++; // 递归边界。只要走到了这里，所有皇后必然不冲突 // if (cur == n) // 打印解 // { // printf(\u0026#34;解%d: \u0026#34;, tot); // for (int i = 0; i \u0026lt; n; i++) // printf(\u0026#34;(%d,%d) \u0026#34;, i, C[i]); // printf(\u0026#34;\\n\u0026#34;); // } else for (int i = 0; i \u0026lt; n; i++) { int ok = 1; C[cur] = i; // 尝试把第cur行的皇后放在第i列 for (int j = 0; j \u0026lt; cur; j++) // 检查是否和前面的皇后冲突 // 对于(x,y),y-x值为主对角线，y+x值为副对角线 if (C[cur] == C[j] || cur-C[cur] == j-C[j] || cur+C[cur] == j+C[j]) { ok = 0; break; } if (ok) search(cur+1); // 如果合法，则继续递归 } } int main() { while (cin \u0026gt;\u0026gt; n) { search(0); cout \u0026lt;\u0026lt; \u0026#34;解的个数: \u0026#34; \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;递归次数: \u0026#34; \u0026lt;\u0026lt; nc \u0026lt;\u0026lt; endl; nc = 0; tot = 0; memset(C, 0, sizeof(C)); } return 0; } 这样就解决了这个问题。结点数似乎很难再减少了，但效率还可以提高！\n优化的回溯法 利用二维数组vis[2][]存储状态，来直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。因为$ y-x $可能为负，存储时要加上n（数组下标不能为负）\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int C[50], vis[3][50], tot = 0, n = 8, nc = 0; // 利用二维数组vis[2][]直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后 void search(int cur) { int i; nc++; if (cur == n) tot++; // if(cur == n) // { // printf(\u0026#34;解%d: \u0026#34;, tot); // for (int i = 0; i \u0026lt; n; i++) // printf(\u0026#34;(%d,%d) \u0026#34;, i, C[i]); // printf(\u0026#34;\\n\u0026#34;); // } else for(i = 0; i \u0026lt; n; i++) { if (!vis[0][i] \u0026amp;\u0026amp; !vis[1][cur+i] \u0026amp;\u0026amp; !vis[2][cur-i+n]) { C[cur] = i; // 如果不用打印解，整个C数组都可以省略 vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1; // 访问标记 search(cur+1); vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0; // 及时改回来！ } } } int main() { while (cin \u0026gt;\u0026gt; n) { memset(vis, 0, sizeof(vis)); search(0); cout \u0026lt;\u0026lt; \u0026#34;解的个数: \u0026#34; \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;递归次数: \u0026#34; \u0026lt;\u0026lt; nc \u0026lt;\u0026lt; endl; tot = 0; nc = 0; } return 0; } 注意访问标记的设置，即对辅助全局变量（数组vis）的修改，并且在结束访问后即使修改回来！\n生成 - 测试法 作为比较，我们看看生成 - 测试法的效率如何\nnqueens_3.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int C[50], tot = 0, n = 8; long long nc = 0; // 先生成棋面，再判断 void search(int cur) { int i, j; nc++; if(cur == n) { for(i = 0; i \u0026lt; n; i++) for(j = i+1; j \u0026lt; n; j++) if(C[i] == C[j] || i-C[i] == j-C[j] || i+C[i] == j+C[j]) return; tot++; } else for(i = 0; i \u0026lt; n; i++) { C[cur] = i; search(cur+1); } } int main() { while (cin \u0026gt;\u0026gt; n) { memset(C, 0, sizeof(C)); search(0); cout \u0026lt;\u0026lt; \u0026#34;解的个数: \u0026#34; \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;递归次数: \u0026#34; \u0026lt;\u0026lt; nc \u0026lt;\u0026lt; endl; tot = 0; nc = 0; } return 0; } 我们来对比一下这几个程序的效率（测试设备CPU为i9-12900H）\n递归次数\n程序 \\ n 8 9 10 11 12 13 14 15 16 nqueen_1.cpp 2057 8394 35539 166926 856189 4674890 27358553 171129072 1141190303 nqueen_2.cpp 2057 8394 35539 166926 856189 4674890 27358553 171129072 1141190303 nqueen_3.cpp 19173961 435848050 11111111111 - - - - - - 耗时（单位：s）\n程序 \\ n 8 9 10 11 12 13 14 15 16 nqueen_1.cpp 0.001 0.002 0.006 0.028 0.147 0.877 5.582 38.462 284.097 nqueen_2.cpp 0.001 0.002 0.003 0.012 0.056 0.298 1.828 11.761 80.594 nqueen_3.cpp 0.124 3.2 91.716 - - - - - - 当 $ n \\leq 13 $ 时，回溯法和优化后的回溯法有不错的效率；当 $ n \u0026gt; 13 $ 时，优化后回溯法的效率明显更高\n而生成-测试法的复杂度明显高得多，$ n = 10 $ 时耗时长达约一分半，递归次数也远超出INT类型的范围\nPython代码 nqueen.py\ndef print_solve(): global tot, n, C print(f\u0026#34;解：{tot}\u0026#34;) for i in range(n): print(f\u0026#34;({i},{C[i]})\u0026#34;, end=\u0026#34; \u0026#34;) print() def search(cur): global C, vis, tot, n, nc nc += 1 if cur == n: tot += 1 if cur == n: print_solve() else: for i in range(n): if vis[0][i] == 0 and vis[1][cur+i] == 0 and vis[2][cur-i+n] == 0: C[cur] = i vis[0][i] = 1 vis[1][cur+i] = 1 vis[2][cur-i+n] = 1 search(cur+1) vis[0][i] = 0 vis[1][cur+i] = 0 vis[2][cur-i+n] = 0 while 1: C = [0]*30 vis = [[0]*30 for _ in range(3)] tot = 0 n = 0 nc = 0 try: n = int(input()) except: print(\u0026#34;error.\u0026#34;) search(0) print(f\u0026#34;解的个数：{tot}\u0026#34;) print(f\u0026#34;递归次数：{nc}\u0026#34;) 效率飞一般的提升！快去试试吧！\n(To be continue\u0026hellip;)\n更新了一些数学公式（终于会用Latex了）——2023/01/12\n附录 参考文献 刘汝佳《算法竞赛入门经典（第2版）》 维基百科·暴力搜索 维基百科·回溯法 维基百科·八皇后问题 ","permalink":"https://blog.allenwu233.com/zh/posts/backtracking/","summary":"减少不必要的枚举","title":"生成和检查的有机结合-回溯法"},{"content":" 原载于bilibili\n第一次写长评论，还请多多指教。 附上作品链接：\n原版 東方幼靈夢【1-7话完結】【內嵌字幕】\n国内up配音版 日语配音：东方幼灵梦 第一话\n正文 感人至深的一部作品，不愧是经典！我一个平时不怎么流泪的人看完后眼睛也湿润了…… 谈点观后感吧。\n消除记忆 关于消除记忆，我认为这是件比死亡还要残酷的事，不论是对露米娅来说还是对幼灵梦。\n就露米娅而言，照紫的说法，被消除记忆和“幼化”的她摆脱了束缚，成功“重生”；但从观众的视角来看，露米娅已经死了：抛除了食人罪孽的同时，失去了过往的美好回忆、遗忘了所爱之人的露米娅，已经不再是当初那个善良可爱、心存感恩的“大”露米娅了。这一情节，极大地增加了本作的悲剧性（好一把大刀）。\n就幼灵梦来说，失去对生命中的两个至爱之人的记忆，更是令人痛心。引用我看过的一篇小说中的话：\n“如果她不活在我的记忆里，就没法存在于任何地方了。” ——《花与爱丽丝》\n如果幼灵梦没被消除与阿妈和露米娅有关的记忆，虽然她要承担亲人离去的痛苦（但这对孩子来说过于残酷了\u0026hellip;\u0026hellip;紫的做法也不是不可理解），但在以后的日子里，回想起那段幸福经历的灵梦，也会露出幸福的笑容吧——阿妈和露米娅已永远活在她的心中。然而事实是残酷的——对于幼灵梦来说，阿妈和露米娅等于从来没有存在过，她甚至连回忆的机会也没有了。这又增加了悲剧的意味啊（又一把大刀）。\n终究是紫承担下了所有……经历了无数次生离死别的她，为了让露米娅得到真正的救赎、让幼灵梦能够健康快乐地成长，即使残酷，也只能消除她们的记忆，而独自咀嚼悲伤。换做是我，可能也会跟紫一样的吧。\n爱与救赎 毋庸置疑，这是一部以爱与救赎为主题的作品。我认为剧情可分为三条线：\n一条是露米娅的救赎之路。由冷酷可怖的食人妖怪变成心怀感恩的老好人，最终摆脱桎梏，重获新生。 一条是阿妈的救赎之路。由备受他人误解与歧视而抑郁的博丽巫女，到乐天知命、享受当下幸福的思想转变。 一条是幼灵梦的救赎之路。由路旁的弃婴，成长为一个被人爱、也会爱人的孩子。 而将这三条线交织在一起，使之密不可分、相互促成的，正是那股伟大的力量——爱。\n显然，这种爱已经上升到亲情程度的爱了。\n本作中，幼灵梦分饭团的情节尤为令我印象深刻。“这样就两个人都肚子饱饱！”抱有这种想法的幼灵梦，已经是个会爱人的人了——既会爱自己，也会爱他人。在我看来，如果幼灵梦只是单纯把饭团全给露米娅的话，就不能算是完美的爱——牺牲自己，再爱他人。正是这种天真单纯的爱，感化了当初的露米娅吧——毕竟，这是第一个把她看作是亲人的人。换个角度来看，也正是这种真诚的爱，解开了阿妈的心结，使她懂得了爱为何物吧。\n其次，还有紫对阿妈、幼灵梦的爱。这大概是紫想杀害小露米娅却又收手的缘故吧——虽然是杀友仇人，却是友人用生命救下的。“明明是个妖怪，却是个老好人，再加上是个爱哭鬼，还是我所爱之人，最好的朋友哟。”\n结局幼灵梦与小露米娅的重聚，或许是我们仅有的慰藉了吧。纵使幼灵梦那句“谁？”令人心酸，让我们祝愿她们能开始一段新的幸福生活吧。\n——Allen 2021.12.30 深夜\n","permalink":"https://blog.allenwu233.com/zh/posts/little-reimu/","summary":"观《东方幼灵梦》有感","title":"记忆、爱与救赎"},{"content":"引言 - 二叉树是什么 在计算机科学中， 二叉树（Binary tree） 是每个结点最多只有两个分支（即不存在分支度大于2的结点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 与普通树不同，普通树的结点个数至少为1，而二叉树的结点个数可以为0；普通树结点的最大分支度没有限制，而二叉树结点的最大分支度为2；普通树的结点无左、右次序之分，而二叉树的结点有左、右次序之分。 ——From 中文维基百科·二叉树\n二叉树是非常重要的数据结构，其独特的结构使得它在搜索和处理数据方面有相当不错的表现\n二叉树的遍历 层次遍历（宽度优先遍历） 顾名思义，即按从上到下、从左到右的顺序遍历结点 以上图为例，遍历的顺序为1～15 这种方法叫 宽度优先遍历（Breadth-First Search, BFS）\n递归遍历（深度优先遍历） 博主认为二叉树的递归遍历是最为精彩的部分。理解其三种递归遍历方式，能一窥二叉树的结构之美\n对于一棵二叉树 T ，可以递归定义它的先序遍历、中序遍历和后序遍历，如下所示：\nPreOrder(T) = T的根结点 + PreOrder(T的左子树) + PreOrder(T的右子树) InOrder(T) = InOrder(T的左子树) + T的根结点 + InOrder(T的右结点) PostOrder(T) = PostOrder(T的左子树) + PostOrder(T的右子树) + T的根结点 这三种遍历都属于递归遍历，或者说 深度优先遍历（Depth-First Search, DFS） ，因为它总是优先往深处访问 ——From 刘汝佳《算法竞赛入门经典（第2版）》 还是以上图为例，来讲一下如何递归遍历： 要遍历整棵二叉树，首先把1,2,3看作一棵小二叉树来遍历，其中1为根，2,3为结点。遍历结点2或3时，再分别把2,4,5或3,6,7看作小二叉树来遍历，依次类推。具体遍历顺序由遍历的方式而定\n是不是很简单？在看下面的答案前，先试着写一下这三种遍历方式的顺序吧\n注：“根”——根结点，“左”——左子树，“右”——右子树 还是上图的例子：\n先序遍历 顺序：根--\u0026gt;左--\u0026gt;右 1 2 4 8 9 5 10 11 3 6 12 13 7 14 15\n中序遍历 顺序：左--\u0026gt;根--\u0026gt;右 8 4 9 2 10 5 11 1 12 6 13 3 14 7 15\n后序遍历 顺序：左--\u0026gt;右--\u0026gt;根 8 9 4 10 11 5 2 12 13 6 14 15 7 3 1\n实例：推导先序遍历 已知二叉树的中序遍历和后续遍历，如何推出这棵二叉树，以写出它的先序遍历？\n用Python风格伪代码来表示,[]代表列表（有序），{}代表集合（无序）\nInOrder = [7, 8, 11, 3, 5, 16, 12, 18] PostOrder = [8, 3, 11, 7, 16, 18, 12, 5] 由后序遍历的特点可知，最后一个字符5就是根，在中序遍历中找到5，把{7, 8, 11, 3}看作左子树，{16, 12, 18}看作右子树，构建一棵二叉树：\n5 / \\ {7, 8, 11, 3} {16, 12, 18} 接着再来看后序遍历，分别在[8, 3, 11, 7] , [16, 18, 12]中找出根，同理分别构建小二叉树：\n5 / \\ 7 12 \\ / \\ {8, 11, 3} 16 18 最后一步：\n5 / \\ 7 12 \\ / \\ 11 16 18 /\\ 8 3 于是我们可以得到它的先序遍历：\nPreOrder = [5, 7, 11, 8, 3, 12, 16, 18] 几道例题 推导先序遍历 即上面例子的代码实现 类似的题目：天依出去玩，以及参考答案\npre_order.py\npre_order, in_order, post_order = [], \u0026#39;\u0026#39;, \u0026#39;\u0026#39; def read_list(): global pre_order, in_order, post_order in_order = input() post_order = input() pre_order = [] in_order = list(map(int, in_order.split())) post_order = list(map(int, post_order.split())) def build_pre(in_order, post_order): \u0026#34;\u0026#34;\u0026#34;递归构建二叉树的先序遍历\u0026#34;\u0026#34;\u0026#34; global pre_order # 直观地看到递归的步骤 print(\u0026#34;in_order = \u0026#34;, in_order) print(\u0026#34;post_order = \u0026#34;, post_order) print(\u0026#34;pre_order = \u0026#34;, pre_order, \u0026#34;\\n\u0026#34;) root = post_order[-1] pre_order.append(root) # 所谓先序遍历，只需在构建子树时记录下根节点即可 root_in_order = in_order.index(root) in_left = in_order[:root_in_order] in_right = in_order[root_in_order+1 : len(in_order)] post_left = post_order[:len(in_left)] post_right = post_order[len(in_left) : -1] if len(post_left): build_pre(in_left, post_left) if len(post_right): build_pre(in_right, post_right) while 1: try: read_list() except: break build_pre(in_order, post_order) print(\u0026#34;PreOrder: \u0026#34;, end=\u0026#39;\u0026#39;) for i in pre_order: print(i, end=\u0026#39; \u0026#39;) print(\u0026#34;\\n\u0026#34;) 输出示例：\n7 8 11 3 5 16 12 18 # 中序遍历 8 3 11 7 16 18 12 5 # 后序遍历 in_order = [7, 8, 11, 3, 5, 16, 12, 18] post_order = [8, 3, 11, 7, 16, 18, 12, 5] pre_order = [] # 读入数据 in_order = [7, 8, 11, 3] post_order = [8, 3, 11, 7] pre_order = [5] # 递归第一步，添加根节点5 in_order = [8, 11, 3] post_order = [8, 3, 11] pre_order = [5, 7] # 递归第二步，添加根节点7 in_order = [8] post_order = [8] pre_order = [5, 7, 11] in_order = [3] post_order = [3] pre_order = [5, 7, 11, 8] in_order = [16, 12, 18] post_order = [16, 18, 12] pre_order = [5, 7, 11, 8, 3] in_order = [16] post_order = [16] pre_order = [5, 7, 11, 8, 3, 12] in_order = [18] post_order = [18] pre_order = [5, 7, 11, 8, 3, 12, 16] PreOrder: 5 7 11 8 3 12 16 18 树的层次遍历（Trees on the level, UVa 122） 题目：\nvjudge PDF 分析：采用动态结构建树。代码出自紫书：\ntrees_on_the_level.cpp\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; const int maxn = 256 + 10; // 节点类型 struct Node { bool have_value; int v; // 节点值 Node *left, *right; Node() : have_value(false), left(NULL), right(NULL){} // 构造函数 }; Node *root; // 二叉树的根节点 Node *newnode() { return new Node(); } bool failed; void addnode(int v, char *s) { int n = strlen(s); Node *u = root; // 从根节点往下走 for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;L\u0026#39;) { if (u-\u0026gt;left == NULL) u-\u0026gt;left = newnode(); // 节点不存在，建立新节点 u = u-\u0026gt;left; // 往右走 } else if (s[i] == \u0026#39;R\u0026#39;) { if (u-\u0026gt;right == NULL) u-\u0026gt;right = newnode(); u = u-\u0026gt;right; } } if (u-\u0026gt;have_value) failed = true; u-\u0026gt;v = v; u-\u0026gt;have_value = true; // 别忘了做标记 } void remove_tree(Node *u) { if (u == NULL) return; // 提前判断比较稳妥 remove_tree(u-\u0026gt;left); // 递归释放左子树空间 remove_tree(u-\u0026gt;right); // 递归释放右子树空间 delete u; // 调用u的析构函数并释放u节点本身的内存 } char s[maxn]; bool read_input() { failed = false; remove_tree(root); // 释放上一棵二叉树的内存 root = newnode(); for (;;) { if (scanf(\u0026#34;%s\u0026#34;, s) != 1) return false; if (!strcmp(s, \u0026#34;()\u0026#34;)) break; int v; sscanf(\u0026amp;s[1], \u0026#34;%d\u0026#34;, \u0026amp;v); addnode(v, strchr(s, \u0026#39;,\u0026#39;) + 1); } return true; } bool bfs(vector\u0026lt;int\u0026gt; \u0026amp;ans) // 宽度优先遍历(Breadth-First Search, BFS) { queue\u0026lt;Node*\u0026gt; q; ans.clear(); q.push(root); // 初始时只有一个根节点 while (!q.empty()) { Node *u = q.front(); q.pop(); if(!u-\u0026gt;have_value) return false; // 有节点没有被赋值过，表明输入有误 ans.push_back(u-\u0026gt;v); // 增加到输出序列尾部 if (u-\u0026gt;left != NULL) q.push(u-\u0026gt;left); // 把左子节点（如果有）放进队列 if (u-\u0026gt;right != NULL) q.push(u-\u0026gt;right); // 把右子节点（如果有）放进队列 } return true; // 输入正确 } int main() { vector\u0026lt;int\u0026gt; ans; while(read_input()) { if(!bfs(ans)) failed = 1; if(failed) printf(\u0026#34;not complete\\n\u0026#34;); else { for(int i = 0; i \u0026lt; ans.size(); i++) { if(i != 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, ans[i]); } printf(\u0026#34;\\n\u0026#34;); } } return 0; } 小结：用结构体 + 指针实现二叉树。当然也可以用数组 + 下标来实现，但仍需具体情况具体分析\n二叉树的递归遍历（Trees, UVa548) 题目：\nvjudge PDF 分析：即已知二叉树的中序遍历和后序遍历，推出先序遍历。还是紫书：\ntrees.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int maxv = 10000 + 10; int in_order[maxv], post_order[maxv], lch[maxv], rch[maxv]; int n; // 因为各个结点的权值各不相同且都是正整数，直接用权值作为结点编号 bool read_list(int *a) { string line; if (!getline(cin, line)) return false; stringstream ss(line); n = 0; int x; while (ss \u0026gt;\u0026gt; x) a[n++] = x; return n \u0026gt; 0; } // 把in_order[L1..R1]和post_order[L2..R2]建成一棵二叉树，返回树根 int build(int L1, int R1, int L2, int R2) { if (L1 \u0026gt; R1) return 0; // 空树 int root = post_order[R2]; int p = L1; while (in_order[p] != root) p++; int cnt = p - L1; // 左子树的结点个数 lch[root] = build(L1, p-1, L2, L2+cnt-1); rch[root] = build(p+1, R1, L2+cnt, R2-1); return root; } int best, best_sum; // 目前为止的最优解和对应的权和 void dfs(int u, int sum) // Deep First Search { sum += u; if (!lch[u] \u0026amp;\u0026amp; !rch[u]) // 叶子 { if (sum \u0026lt; best_sum || (sum == best_sum \u0026amp;\u0026amp; u \u0026lt; best)) { { best = u; best_sum = sum; } } if (lch[u]) dfs(lch[u], sum); if (rch[u]) dfs(rch[u], sum); } } int main() { while (read_list(in_order)) { read_list(post_order); build(0, n-1, 0, n-1); best_sum = 1000000000; dfs(post_order[n-1], 0); cout \u0026lt;\u0026lt; best \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 小结：难点在于理解利用数组lch和rch来储存节点的左右子树以及建树的过程。 建议自己画一下示意图帮助理解\n天平（Not so Mobile, UVa 839） 题目： PDF 分析：递归定义二叉树。还是紫书，代码相当精简、巧妙，值得一学：\nnot_so_mobile.cpp\n#include \u0026lt;iostream\u0026gt; using namespace std; // 输入一个子天平，返回子天平是否平衡，参数W修改为子天平的总重量 bool solve(int \u0026amp;W) { int W1, D1, W2, D2; bool b1 = true, b2 = true; cin \u0026gt;\u0026gt; W1 \u0026gt;\u0026gt; D1 \u0026gt;\u0026gt; W2 \u0026gt;\u0026gt; D2; if (!W1) b1 = solve(W1); if (!W2) b2 = solve(W2); W = W1 + W2; return b1 \u0026amp;\u0026amp; b2 \u0026amp;\u0026amp; (W1 * D1 == W2 * D2); // b1:左 b2:右 } int main() { int T, W; cin \u0026gt;\u0026gt; T; while (T--) { if (solve(W)) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; if (T) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } not_so_mobile.py\ndef solve(W): b1, b2 = True, True W1, D1, W2, D2 = map(int, input().split()) if W1 == 0: b1 = solve(W1) if W2 == 0: b2 = solve(W2) W = W1 + W2 return b1 and b2 and (W1*D1 == W2*D2) W = 0 T = int(input()) while T \u0026gt; 0: T -= 1 print(\u0026#34;YES\u0026#34;) if solve(W) else print(\u0026#34;No\u0026#34;) if T: print(\u0026#34;\\n\u0026#34;) 似乎翻译成 Python 后可读性更强（\nPython类实现二叉树 面向对象真的很有意思，从无到有搓出一个功能完善的类 ，其兴奋感不亚于在mc中造出一台生电机器（\ntree.py\nclass Node(object): \u0026#34;\u0026#34;\u0026#34;节点类\u0026#34;\u0026#34;\u0026#34; def __init__(self, data=None, left_child=None, right_child=None): self.data = data self.left_child = left_child self.right_child = right_child class Tree(object): def __init__(self): self.root = Node() def rec_pre_order(self, node=None): \u0026#34;\u0026#34;\u0026#34;递归实现前序遍历\u0026#34;\u0026#34;\u0026#34; if node: print(node.data, end=\u0026#34; \u0026#34;) self.rec_pre_order(node.left_child) self.rec_pre_order(node.right_child) def pre_order(self): \u0026#34;\u0026#34;\u0026#34;非递归实现前序遍历\u0026#34;\u0026#34;\u0026#34; if self.root: ls = [self.root] while ls: node = ls.pop() print(node.data, end=\u0026#34; \u0026#34;) if node.right_child: ls.append(node.right_child) if node.left_child: ls.append(node.left_child) def pre_order2(self): \u0026#34;\u0026#34;\u0026#34;非递归实现前序遍历\u0026#34;\u0026#34;\u0026#34; stack = [] node = self.root while node or stack: while node: print(node.data, end=\u0026#34; \u0026#34;) stack.append(node) node = node.left_child if stack: node = stack.pop() node = node.right_child def rec_in_order(self, node): \u0026#34;\u0026#34;\u0026#34;递归实现中序遍历\u0026#34;\u0026#34;\u0026#34; if node: self.rec_in_order(node.left_child) print(node.data, end=\u0026#34; \u0026#34;) self.rec_in_order(node.right_child) def in_order(self): \u0026#34;\u0026#34;\u0026#34;非递归实现中序遍历\u0026#34;\u0026#34;\u0026#34; ls = [] node = self.root while node or len(ls): while node: ls.append(node) node = node.left_child if len(ls): node = ls.pop() print(node.data, end=\u0026#34; \u0026#34;) node = node.right_child def in_order2(self): \u0026#34;\u0026#34;\u0026#34;非递归实现中序遍历\u0026#34;\u0026#34;\u0026#34; stack = [] node = self.root while node: while node: if node.right_child: stack.append(node.right_child) stack.append(node) node = node.left_child node = stack.pop() while stack and (not node.right_child): print(node.data, end=\u0026#34; \u0026#34;) node = stack.pop() print(node.data, end=\u0026#34; \u0026#34;) if stack: node = stack.pop() else: node = None def rec_post_order(self, node): \u0026#34;\u0026#34;\u0026#34;递归实现后序遍历\u0026#34;\u0026#34;\u0026#34; if node: self.rec_post_order(node.left_child) self.rec_post_order(node.right_child) print(node.data, end=\u0026#34; \u0026#34;) def post_order(self, node): \u0026#34;\u0026#34;\u0026#34;非递归实现后序遍历\u0026#34;\u0026#34;\u0026#34; q = node ls = [] while node: while node.left_child: ls.append(node) node = node.left_child while node and (node.right_child is None or node.right_child == q): print(node.data, end=\u0026#34; \u0026#34;) q = node if not ls: return node = ls.pop() ls.append(node) node = node.right_child def get_depth(self): \u0026#34;\u0026#34;\u0026#34;计算树的深度，递归树的左右节点,取值大的深度\u0026#34;\u0026#34;\u0026#34; def _depth(node): if not node: return 0 else: left_depth = _depth(node.left_child) right_depth = _depth(node.right_child) if left_depth \u0026gt; right_depth: return left_depth + 1 else: return right_depth + 1 return _depth(self.root) def get_leaves(self, node): \u0026#34;\u0026#34;\u0026#34;递归输出所有叶子节点\u0026#34;\u0026#34;\u0026#34; if node: if not node.left_child and not node.right_child: print(node.data, end=\u0026#34; \u0026#34;) else: self.get_leaves(node.left_child) self.get_leaves(node.right_child) if __name__ == \u0026#39;__main__\u0026#39;: tree = Tree() tree.root = Node(\u0026#39;A\u0026#39;) tree.root.left_child = Node(\u0026#39;B\u0026#39;) tree.root.right_child = Node(\u0026#39;C\u0026#39;) tree.root.left_child.left_child = Node(\u0026#39;D\u0026#39;) tree.root.left_child.right_child = Node(\u0026#39;E\u0026#39;) tree.root.left_child.right_child.right_child = Node(\u0026#39;F\u0026#39;) tree.root.left_child.left_child.right_child = Node(\u0026#39;G\u0026#39;) print(\u0026#34;\u0026#34;\u0026#34; A | ------------- | | B C | ------------- | | D E | | ------- ------- | | | | (None) G (None) F \u0026#34;\u0026#34;\u0026#34;) print(\u0026#34;#先序遍历\u0026#34;) print(\u0026#34;递归：\u0026#34;) tree.rec_pre_order(tree.root) print(\u0026#34;\\n非递归1：\u0026#34;) tree.pre_order() print(\u0026#34;\\n非递归2：\u0026#34;) tree.pre_order2() print(\u0026#34;\\n\\n#中序遍历\u0026#34;) print(\u0026#34;递归：\u0026#34;) tree.rec_in_order(tree.root) print(\u0026#34;\\n非递归1：\u0026#34;) tree.in_order() print(\u0026#34;\\n非递归2：\u0026#34;) tree.in_order2() print(\u0026#34;\\n\\n#后序遍历\u0026#34;) print(\u0026#34;递归：\u0026#34;) tree.rec_post_order(tree.root) print(\u0026#34;\\n非递归：\u0026#34;) tree.post_order(tree.root) print(\u0026#34;\\n\\n二叉树的深度为：\u0026#34;, tree.get_depth()) print(\u0026#34;\\n叶子节点：\u0026#34;, end=\u0026#34;\u0026#34;) tree.get_leaves(tree.root) 二叉查找树 （先挖个坑，以后回来更新）\n参考文献 中文维基百科·二叉树 刘汝佳《算法竞赛入门经典（第2版） ","permalink":"https://blog.allenwu233.com/zh/posts/binary-tree/","summary":"最近看什么都像二叉树（","title":"数据结构之美-二叉树"},{"content":" 如果说算法是程序的灵魂，那么数据结构就如同程序的躯体。 学习数据结构，一定少不了基础而经典的——栈(stack) 那么，栈是什么？\n什么是栈 Stack 是东方Project同人音乐社团「暁records」主唱/作词/偶尔作曲/编曲，拥有的独特嗓音,虽然有些人不喜欢,但是从来不会被忽略,一入耳就能留下永远无法忘记的印象\u0026hellip;\u0026hellip; \u0026gt; 咳咳\u0026hellip;\u0026hellip;正经的：\nIn computer science, a stack is an abstract data type that serves as a collection of elements, with two main operations:\nPush, which adds an element to the collection, and Pop, which removes the most recently added element that was not yet removed. \u0026mdash;\u0026mdash;from WIKIPEDIA 简言之，栈（stack，又称为堆栈或堆叠）就是符合 “后进先出”(Last In First Out, LIFO) 规则的线性存储结构，有PUSH和POP两种操作\nPUSH: 压栈，把元素压入栈顶 POP: 弹出：从栈顶把元素弹出 由此我们知道，元素只能从栈顶入、从栈顶出，而不能从栈底进出 把栈比作一个直径为一颗糖果大小、封底无盖的糖果盒，要想存取糖果，只能从开口的一端来——每次操作都只与栈顶元素相关 代码实现 例题 用一道例题来说明栈的用途：铁轨(Rails, ACM/ICPC CERC 1997, UVa 514) 题目略有改动\nSummary \u0026gt; There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.\nExplanation \u0026gt; The problem requires reordering items on a stack, specifically to determine if the reordering can be done in a single pass.\nInput Sample\n5 1 2 3 4 5 5 5 4 1 2 3 6 6 5 4 3 2 1 Ouput Sample\nYes No Yes C++ C++ 的 STL 提供了包括栈在内等特殊的数据结构，可以很方便地调用。参考了刘汝佳老师的代码\nrails.cpp\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int MAXN = 1000 + 10; int n, target[MAXN]; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1) { stack\u0026lt;int\u0026gt; s; int A = 1, B = 1; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[i]); int ok = 1; while (B \u0026lt;= n) { if (A == target[B]) { A++; B++; } else if (!s.empty() \u0026amp;\u0026amp; s.top() == target[B]) { s.pop(); B++; } else if (A \u0026lt;= n) s.push(A++); else { ok = 0; break; } } printf(\u0026#34;%s\\n\u0026#34;, ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); } return 0; } Python Python再翻译 Python内置的数据结构相当强大，可以轻松模拟栈\nrails.py\nwhile 1: n = input() if n == \u0026#34;\u0026#34;: break n = int(n) s = [] target = [0] + list(map(int, input().split())) A, B, ok = 1, 1, 1 while B \u0026lt;= n: if A == target[B]: A += 1 B += 1 elif len(s) != 0 and s[-1] == target[B]: s.pop(-1) B += 1 elif A \u0026lt;= n: A += 1 s.append(A) else: ok = 0 break if ok == 1: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) EX: Python类实现Stack 利用list这一好用的内置数据结构，我们可以用Python类来实现栈\nstack.py\nclass Stack(object): __slots__ = (\u0026#39;__items\u0026#39;) # 限定Stack类的成员只有__items # 初始化栈为空列表 def __init__(self): self.__items = [] # 私有属性 # 判断栈是否为空，返回布尔值 def empty(self): return self.__items == [] # 返回栈顶元素 def top(self): return self.__items[-1] # 返回栈的大小 def size(self): return len(self.__items) # 把新的元素堆进栈里面（程序员喜欢把这个过程叫做压栈，入栈，进栈……） def push(self, item): self.__items.append(item) # 把栈顶元素丢出去（程序员喜欢把这个过程叫做出栈……） def pop(self): return self.__items.pop(-1) if __name__ == \u0026#39;__main__\u0026#39;: # 初始化一个栈对象 my_stack = Stack() # 把\u0026#39;candy_01\u0026#39;丢进栈里 my_stack.push(\u0026#39;candy_01\u0026#39;) # 把\u0026#39;candy_02\u0026#39;丢进栈里 my_stack.push(\u0026#39;candy_02\u0026#39;) # 看一下栈的大小（有几个元素） print(my_stack.size()) # 打印栈顶元素 print(my_stack.top()) # 把栈顶元素丢出去，并打印出来 print(my_stack.pop()) # 再看一下栈顶元素是谁 print(my_stack.top()) # 这个时候栈的大小是多少？ print(my_stack.size()) # 再丢一个栈顶元素 print(my_stack.pop()) # 看一下栈的大小 print(my_stack.size()) # 栈是不是空了？ print(my_stack.empty()) # 哇~真好吃~ print(\u0026#39;Yummy~\u0026#39;) ","permalink":"https://blog.allenwu233.com/zh/posts/stack/","summary":"简单而又不简单","title":"数据结构初见-栈"},{"content":" 有人说贪心算法是最简单的算法，原因很简单：你我其实都很贪，根本不用学就知道怎么贪。有人说贪心算法是最复杂的算法，原因也很简单：这世上会贪的人太多了，那轮到你我的份？ ——By CSDN@lloil\n贪心算法简介 什么是贪心算法 贪心算法（greedy algorithm，又称贪婪算法） 是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。 ——By 百度百科·贪心算法\n基本要素 1.贪心选择性质\n一个问题的整体最优解可通过一系列局部的最优解的选择，即贪心选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质。 对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解\n2.最优子结构性质\n当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。 问题的最优子结构性质是该问题可用贪心法求解的关键所在。在实际应用中，至于什么问题具有什么样的贪心选择性质是不确定的，需要具体问题具体分析\n基本思路 从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。\n该算法存在问题：\n不能保证求得的最后解是最佳的； 一般用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 实现该算法的过程： 从问题的某一初始解出发:\nwhile 能朝给定总目标前进一步: 求出可行解的一个解元素 由所有解元素组合成问题的一个可行解 一道简单的例题 题目如下 原题：拼座椅\n题目描述\n上课的时候总有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。 不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的$D$对同学上课时会交头接耳。\n同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是$(i，j)$，为了方便同学们进出， 在教室中设置了 $K$ 条横向的通道，$L$条纵向的通道。 于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题： 她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了两个会交头接耳的同学，那么他们就不会交头接耳了。\n请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生对数最少。\n输入描述:\n第一行，有 5 个用空格隔开的整数，分别是 $M，N，K，L，D（2 \\leq N，M \\leq 1000，0 \\leq K \u0026lt; M，0 \\leq L \u0026lt; N，D \\leq 2000）$。\n接下来 D 行，每行有 4 个用空格隔开的整数，第 i 行的 4 个整数 $X_i$，$Y_i$，$P_i$，$Q_i$， 表示坐在位置 $(X_i, Y_i)$ 与 $(P_i, Q_i)$ 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。\n输入数据保证最优方案的唯一性。\n输出描述\n共两行：\n第一行包含 $K$ 个整数， $a_1, a_2, \\dots, a_k$， 表示第 $a_1$ 行和 $a_1 + 1$ 行之间、第 $a_2$ 行和第 $a_2 + 1$ 行之间、\u0026hellip;、第 $a_k$ 行和 第 $a_k + 1$ 行之间要开辟通道，其中 $a_i \u0026lt; a_i + 1$ ，每两个整数之间用空格隔开（行尾没有空格）。\n第二行包含 $L$ 个整数， $b_1, b_2, \\dots, b_k$，表示第 $b_1$ 列和 $b_1 + 1$ 行之间、 第 $b_2$ 行和第 $b_2 + 1$ 行之间、\u0026hellip;、第 $b_l$ 行和第 $b_l + 1$ 行之间要开辟通道，其中 $b_l \u0026lt; b_l + 1$，每两个整数之间用空格隔开（行尾没有空格）。\n示例\n输入\n4 5 1 2 3 4 2 4 3 2 3 3 3 2 5 2 4 输出\n2 2 4 说明\n上图中用符号*、※、+ 标出了3对会交头接耳的学生的位置，图中3条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。\n题目分析 这是一道典型的贪心算法题。要满足交头接耳的学生对数最少，只需选择能分开学生对数最多的行和列即可。 有人把这道题比喻成切虫子：有若干条长度为 2 的 虫子，怎么切才能使切死的虫子数最多（莉格露表示强烈谴责）\n然而即便是这么简单的题，也有不少 难点/陷阱\n注意输出：行尾没有空格 升序输出 重点(针对 C 语言)：如何在一个数组中求值前 k 大的值（不改变下标） 冒泡排序 关于第三点的说明 如：求int arr[] = {1, 7, 6, 8, 32}中第一大的值、第二大的值、第三大的值\u0026hellip;\u0026hellip;\n方法：\n在外面定义int max_num = 0，然后遍历数组，比max_num大的值就将它赋给max_num，即获取最大值 再次遍历数组，将第一个数组值等于max_num的值置为-1，这样下一次求得的是第二大的值 重复步骤1、2，直至求得所有待求值 理论成立，上 ~ 代 ~ 码 ~\n源代码 C #include \u0026lt;stdio.h\u0026gt; void bubble_sort(int a[], int size) { int i, j, temp; for (i=0; i\u0026lt;size-1; i++) { for (j=0; j\u0026lt;size-i-1; j++) { if (a[j] \u0026gt; a[j+1]) { temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } void get_result(int a[], int n, int k) { int i=1, j, max_num, max[k]; while (i \u0026lt;= k) /* 获取第 i 大值 */ { max_num = 0; for (j=0; j\u0026lt;n; j++) { if (a[j] \u0026gt; max_num) { max_num = a[j]; max[k-i] = j+1; } } a[max[k-i]-1] = -1; /* 第三点(2.2.1) 2. */ i++; } bubble_sort(max, k); /* 冒泡排序以便升序输出 */ for (j=0; j\u0026lt;k; j++) { if (j != k-1) printf(\u0026#34;%d \u0026#34;, max[j]); else printf(\u0026#34;%d\\n\u0026#34;, max[j]); } } int main() { int m, n, k, l, d, i; scanf(\u0026#34;%d %d %d %d %d\u0026#34;, \u0026amp;m, \u0026amp;n, \u0026amp;k, \u0026amp;l, \u0026amp;d); int x[d], y[d], p[d], q[d], ak[m], bl[n]; for (i=0; i\u0026lt;m; i++) { ak[i] = 0; } for (i=0; i\u0026lt;n; i++) { bl[i] = 0; } for (i=0; i\u0026lt;d; i++) { scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;x[i], \u0026amp;y[i], \u0026amp;p[i], \u0026amp;q[i]); } for (i=0; i\u0026lt;d; i++) { if (y[i] == q[i]) { if (x[i] \u0026gt; p[i]) ak[p[i]-1]++; else ak[x[i]-1]++; } else { if (y[i] \u0026gt; q[i]) bl[q[i]-1]++; else bl[y[i]-1]++; } } get_result(ak, m, k); get_result(bl, n, l); return 0; } Python 参考：@comter\nPython 的map()、count()和sort()等函数可以省不少功夫 这就是我更喜欢 Python 的原因之一（笑）\ndef get_result(lis, q): \u0026#34;\u0026#34;\u0026#34;冒泡排序\u0026#34;\u0026#34;\u0026#34; result_list = list(set(lis)) for i in range(len(result_list)): for j in range(len(result_list) - i - 1): if lis.count(result_list[j]) \u0026lt; lis.count(result_list[j+1]): result_list[j], result_list[j+1] = result_list[j+1], result_list[j] result_list = result_list[:q] result_list.sort() # 还是Python香（ return \u0026#39; \u0026#39;.join(map(str, result_list)) m, n, k, l, d = map(int, input().split()) # map()会根据提供的函数对指定序列做映射 ak, bl = [], [] for i in range(d): x, y, p, q = map(int, input().split()) if x == p: bl.append(min(y, q)) else: ak.append(min(x, p)) print(get_result(ak, k)) print(get_result(bl, l)) 才二十几行代码就解决了 C 七十几行代码才解决的问题\n总结 算法不愧是编程的灵魂\u0026hellip;\u0026hellip; 这才是编程的浪漫啊！（因解题时间过长理智丧失ing\u0026hellip;） 参考文献 贪心算法详解 百度百科·贪心算法 To Be Continue 关于贪心算法，我只是学了点皮毛而已，以后还会在这里更新更加deep♂dark的用法\n","permalink":"https://blog.allenwu233.com/zh/posts/greedy-algorithm/","summary":"这破题我写了三天.jpg","title":"最“简单”的算法——贪心算法"},{"content":"事情的起因还得从昨天说起：\n博主在刷几道简单的算法题，其中有一道是多项式输出，看似简单决定首先AC，无奈博主 C 语言能力不足，转战Python。 结果还是眼高手低，这么简单的程序要这么多判断\n生成多项式 参考了原题，但是输入输出的格式稍有不同\nget_polynomial_feature.py\ndef get_polynomial(*n): \u0026#34;\u0026#34;\u0026#34;生成多项式。第一个形参为次数，其他形参为系数\u0026#34;\u0026#34;\u0026#34; power, coefficients = n[0], {} for i in range(power+1): coefficients[\u0026#39;a\u0026#39; + str(i+1)] = n[i+1] # 存储系数的字典 counter = 0 polynomial = \u0026#34;\u0026#34; while counter \u0026lt;= power: poly = coefficients[f\u0026#39;a{counter+1}\u0026#39;] if abs(poly) != 1: # 判断系数绝对值是否为1 if counter != 0: # 判断是否为最高次项 if power-counter != 1: # 判断是否为一次项 if counter != power: # 判断是否为常数项 if poly \u0026gt; 0: polynomial += f\u0026#34;+{poly}*x**{power-counter}\u0026#34; elif poly \u0026lt; 0: polynomial += f\u0026#34;{poly}*x**{power-counter}\u0026#34; else: pass else: if poly \u0026gt; 0: polynomial += \u0026#39;+\u0026#39; + str(poly) elif poly \u0026lt; 0: polynomial += \u0026#39;-\u0026#39; + str(poly) else: pass else: if poly \u0026gt; 0: polynomial += \u0026#34;+\u0026#34; + str(poly) + \u0026#34;*x\u0026#34; elif poly \u0026lt; 0: polynomial += \u0026#34;-\u0026#34; + str(poly) + \u0026#34;*x\u0026#34; else: pass else: if poly \u0026gt; 0: polynomial += f\u0026#34;{poly}*x**{power-counter}\u0026#34; elif poly \u0026lt; 0: polynomial += f\u0026#34;{poly}*x**{power-counter}\u0026#34; else: pass else: if counter != 0: if power-counter != 1: if counter != power: if poly \u0026gt; 0: polynomial += f\u0026#34;+x**{power-counter}\u0026#34; else: polynomial += f\u0026#34;-x**{power-counter}\u0026#34; else: if poly \u0026gt; 0: polynomial += \u0026#39;+1\u0026#39; else: polynomial += \u0026#39;-1\u0026#39; else: if poly \u0026gt; 0: polynomial += \u0026#34;+x\u0026#34; else: polynomial += \u0026#34;-x\u0026#34; else: if poly \u0026gt; 0: polynomial += f\u0026#34;x**{power-counter}\u0026#34; elif poly \u0026lt; 0: polynomial += f\u0026#34;-x**{power-counter}\u0026#34; else: pass counter += 1 return polynomial if __name__ == \u0026#39;__main__\u0026#39;: print(get_polynomial(3, 5, -1, 0, 11)) 关于上面代码的吐槽：\n高情商：为锻炼编程能力，坚决不使用第三方库； 低情商：瞎堆砌代码，头铁重新发明轮子 牛顿法求多项式近似根 最近在复习普林斯顿，正好来试试牛顿法\n理论基础 牛顿法 假设a是对方程 $f(x) = 0$ 的解的一个近似. 如果令 $b = a - f(a) / f\u0026rsquo;(a)$， 则在很多情况下，$b$ 是个比 $a$ 更好的近似.\n暂时不考虑牛顿法失效的情况（详见《普林斯顿微积分读本》P260~262）\n代码 newtons_method.py\nfrom sympy import * from get_polynomial_feature import * x = symbols(\u0026#39;x\u0026#39;) # x为符号变量 x0 = -0.5 # 初值 x_list = [x0] i = 0 # 计数器 polynomial_feature = get_polynomial(3, 5, -1, 0, 11) # 待求解多项式 def f(x): f = eval(polynomial_feature) return f while True: if diff(f(x), x).subs(x, x0) == 0: # subs()将变量x替换为x0;若f\u0026#39;(x0)=0 print(\u0026#34;极值点：\u0026#34;, x0) break else: x0 = x0 - f(x0) / diff(f(x), x).subs(x, x0) # 牛顿法 x_list.append(x0) if len(x_list) \u0026gt; 1: i += 1 error = abs((x_list[-1] - x_list[-2]) / x_list[-1]) # 计算误差 if error \u0026lt; 10 ** (-6): print(f\u0026#34;迭代第 {i} 次后，误差小于 10^(-6)，误差为 {error}\u0026#34;) break else: pass print(f\u0026#34;{polynomial_feature} 的根为 {x_list[-1]}\u0026#34;) 运行结果示例\n迭代第 7 次后，误差小于 10^(-6)，误差为 4.12656549474007E-8 5*x**3-x**2+11 的根为 -1.23722554155332 ***Repl Closed*** 总结 当 Python 遇上数学，还挺有意思的\n有机会博主要学一下SymPy和Numpy库\n源代码仓库 感兴趣的话可以star一下（真的会有人star这么无聊的代码吗）\n参考文献 [1]（美）阿德里安·班纳.普林斯顿微积分读本[M].北京：人民邮电出版社2016.\n[2]牛顿迭代法（Newton’s Method）迭代求根的Python程序\n","permalink":"https://blog.allenwu233.com/zh/posts/poly-newton/","summary":"Python 与数学的碰撞","title":"Python生成多项式与牛顿法"},{"content":"引言 在印度，有这样一个古老的传说。在世界中心贝拿勒斯的圣庙里， 一块黄铜板上插着3根宝石针。印度教的主神梵天在创造世界的时候， 在其中一根针上从下到上地穿好了由大到小的64片金盘， 这就是所谓的汉诺塔(Tower of Hanoi)。 不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金盘到另一根针上： 一次只移动一片，而且小片必在大片上面。 当所有的金盘都从梵天穿好的那根针上移动到第三根针上时， 世界就将在一声霹雳中消灭，梵塔、庙宇和众生都将同归于尽\u0026hellip;\u0026hellip;\n分析问题 什么是汉诺塔 总结如下： 有 A, B, C 三根柱子，A 柱上有 n(n \u0026gt; 1) 个金盘，金盘的尺寸由下到上依次变小。 每次只能移动一片金盘，且大金盘不能位于小金盘之上，使得所有金盘都移动到 C 柱。 问：如何移？最少要移动多少次？\n一个最简单的例子 当 n = 1 时，只需1步就能解决：A--\u0026gt;C ( A--\u0026gt;C 表示把 A 柱最上面的一个金盘移动到 C 柱，下同)\n一个很简单的例子 当 n = 2 时，只需3步：\nA--\u0026gt;B A--\u0026gt;C B--\u0026gt;C 一个简单的例子 当 n = 3 时，用一张图来解决：\n用语言表述如下：\nA--\u0026gt;C A--\u0026gt;B C--\u0026gt;B A--\u0026gt;C B--\u0026gt;A B--\u0026gt;C A--\u0026gt;C 共需7步\n扩展到 n 当 n = 4, 5, 6 甚至 20 时，又该怎么办呢？ 这个问题看起来很复杂，其实是有规律可循的 根据数学方法计算得出，移动 n 层的汉诺塔所需次数为 $2^n - 1$\n关于具体证明的讨论就不属于本文的范畴了\n分析算法 可以用递归的思想来解决 将n个金盘从A柱移动到C柱可分解为以下三个步骤：\n先将 A 柱上的 n-1 个金盘借助于 C 柱移到 B 柱上（把 C 看作临时柱） 这一步又可分解为以下三步： 将 A 柱上的 n-2 个金盘借助于 B 柱移到 C 柱上 将 A 柱上的第 n-1 个金盘移到 B 柱上 再将 C 柱上的 n-2 个金盘借助于 A 柱移到 B 柱上 然后将 A 柱上的最后一个金盘移到 C 柱上 再将 B 柱上的 n-1 金盘借助于 A 柱移到 C 柱上 是不是有点递归的意思了？ 博主最近在学习 C 语言，所以试着用 C 来实现这个算法。代码如下\n代码 C # include \u0026lt;stdio.h\u0026gt; /* 汉诺塔问题，输入金盘的数量 n ，输出将 n 个金盘从 A 柱（借助 B 柱）移动到 C 柱 的过程 */ int counter = 0; /* 初始化计数器 */ void move(char x, char y) /* 输出一次移动 */ { printf(\u0026#34;\\n%c--\u0026gt;%c\u0026#34;, x, y); counter++; } void hanoi(int n, char one, char two, char three) /* 汉诺塔的递归算法 */ { if (n == 1) { move(one, three); } else { hanoi(n-1, one, three, two); move(one, three); /* 把 two 看作临时柱 */ hanoi(n-1, two, one, three); } } int main() { for(;;) /* 实现多次模拟 */ { int n; printf(\u0026#34;汉诺塔层数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); hanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;); printf(\u0026#34;\\n\\n移动次数：%d\\n\\n\u0026#34;, counter); counter = 0; /* 重置计数器 */ } } Python 当然也少不了Python啦\n# 汉诺塔问题，输入金盘的数量 n ，输出将 n 个金盘从 A 柱（借助 B 柱） # 移动到 C 柱 的过程 counter = 0 # 初始化计数器 def move(x, y): \u0026#39;\u0026#39;\u0026#39;输出一次移动\u0026#39;\u0026#39;\u0026#39; global counter print(f\u0026#34;{x}--\u0026gt;{y}\u0026#34;) counter += 1 def hanoi(n, one, two, three): \u0026#39;\u0026#39;\u0026#39;汉诺塔的递归算法\u0026#39;\u0026#39;\u0026#39; if n == 1: move(one, three) else: hanoi(n-1, one, three, two) move(one, three) hanoi(n-1, two, one, three) while 1: n = int(input(\u0026#34;汉诺塔层数：\u0026#34;)) hanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) print(f\u0026#34;移动次数：{counter}\\n\u0026#34;) counter = 0 # 重置计数器 结语 想起一句名言\n算法 + 数据结构 = 程序\n这是博主第一次真正认真学习算法，从此打开了新世界的大门（笑）\n参考文献 于延.C语言程序设计与实践[M].北京：清华大学出版社，2018（2019重印） ","permalink":"https://blog.allenwu233.com/zh/posts/hanoi/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在印度，有这样一个古老的传说。在世界中心贝拿勒斯的圣庙里，\n一块黄铜板上插着3根宝石针。印度教的主神梵天在创造世界的时候，\n在其中一根针上从下到上地穿好了由大到小的64片金盘，\n这就是所谓的汉诺塔(Tower of Hanoi)。\n不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金盘到另一根针上：\n一次只移动一片，而且小片必在大片上面。\n当所有的金盘都从梵天穿好的那根针上移动到第三根针上时，\n世界就将在一声霹雳中消灭，梵塔、庙宇和众生都将同归于尽\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"分析问题\"\u003e分析问题\u003c/h2\u003e\n\u003ch3 id=\"什么是汉诺塔\"\u003e什么是汉诺塔\u003c/h3\u003e\n\u003cp\u003e总结如下：\n有 A, B, C 三根柱子，A 柱上有 n(n \u0026gt; 1) 个金盘，金盘的尺寸由下到上依次变小。\n每次只能移动一片金盘，且大金盘不能位于小金盘之上，使得所有金盘都移动到 C 柱。\n问：如何移？最少要移动多少次？\u003c/p\u003e\n\u003ch3 id=\"一个最简单的例子\"\u003e一个最简单的例子\u003c/h3\u003e\n\u003cp\u003e当 n = 1 时，只需1步就能解决：\u003ccode\u003eA--\u0026gt;C\u003c/code\u003e\n( \u003cstrong\u003eA--\u0026gt;C\u003c/strong\u003e 表示把 A 柱最上面的一个金盘移动到 C 柱，下同)\u003c/p\u003e\n\u003ch3 id=\"一个很简单的例子\"\u003e一个很简单的例子\u003c/h3\u003e\n\u003cp\u003e当 n = 2 时，只需3步：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;B\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eB--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"一个简单的例子\"\u003e一个简单的例子\u003c/h3\u003e\n\u003cp\u003e当 n = 3 时，用一张图来解决：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"三层汉诺塔\" loading=\"lazy\" src=\"/img/hanoi_3.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e用语言表述如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;B\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eC--\u0026gt;B\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eB--\u0026gt;A\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eB--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eA--\u0026gt;C\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e共需7步\u003c/p\u003e\n\u003ch3 id=\"扩展到-n\"\u003e扩展到 n\u003c/h3\u003e\n\u003cp\u003e当 n = 4, 5, 6 甚至 20 时，又该怎么办呢？\n这个问题看起来很复杂，其实是有规律可循的\n根据数学方法计算得出，移动 n 层的汉诺塔所需次数为 $2^n - 1$\u003c/p\u003e","title":"C语言初学者的汉诺塔"},{"content":"Hello Hugo Blog World Python苦手不会用Django搭建博客，连夜转战hugo（迫真\n既然是第一篇博客，多写几个“hello world”的话会有好运气的吧（笑）\nhello_world.py\nfor _ in range(10): print(\u0026#34;Hello world!\u0026#34;) ","permalink":"https://blog.allenwu233.com/zh/posts/hello-world/","summary":"Allen的第一篇博客","title":"Hello World!"},{"content":"欢迎来到又一座“孤岛” 我一直认为个人博客是一座孤岛。身为博主，勤于开拓友链的航线，将一座座孤岛连结起来，形成一张星罗密布的无向图。这样不仅方便互相学习交流，还能顺着大佬们的友链认识更多大佬，何乐而不为？\n不管你是从搜索引擎过来的，还是顺着他人的友链找到我，欢迎多多评论，交流知识与哲思！\n关于我 from base64 import b64decode class Me: def __init__(self): self.name = \u0026#34;Allen Wu\u0026#34; self.hobbies = [\u0026#34;jogging\u0026#34;, \u0026#34;harmonica\u0026#34;, \u0026#34;reading\u0026#34;, \u0026#34;programming\u0026#34;] self.fav_OS = [\u0026#34;Arch Linux\u0026#34;, \u0026#34;LineageOS\u0026#34;] self.fav_programming_languages = [\u0026#34;Python\u0026#34;, \u0026#34;Rust\u0026#34;] self.fav_games = [\u0026#34;Touhou\u0026#34;, \u0026#34;Minecraft\u0026#34;, \u0026#34;Outer Wilds\u0026#34;] self.email = b64decode(\u0026#34;YWxsZW53dTIzM0BvdXRsb29rLmNvbQ==\u0026#34;).decode(\u0026#34;utf-8\u0026#34;) FOSS 爱好者，自从用上了Arch Linux之后更是一发而不可收抬 （有一定程度的开源洁癖） 很爱折腾（从各种杂七杂八的教程可见一斑） 关于本站 名称由来 「逍遥」取自《庄子·内篇·逍遥游》，同时还很喜欢陶渊明笔下那种田园牧歌般的生活，于是为一个 Minecraft 原版生存存档命名为「逍遥乡」，寓意「心灵舒放之地」。本站也借用了这个名称\n网站变迁 2022/08/16，建站，基于 Hugo 生成的静态博客，主题为 Hugo Theme Stack 。部署在 Github Page 和 Netlify，最初站名为“Allen_Wu233\u0026rsquo;s Blog” 2023/05/24，购入个人域名，博客域名更新为：blog.allenwu233.com 2024/05/xx - 2025/04/07，因 Netlify 出了点问题，SSL 证书过期，博客暂挂 2025/04/08，更新主题为 Hugo PaperMod，站名改为“逍遥乡 | Allen\u0026rsquo;s World”，修复 SSL 证书问题，博客恢复正常访问 ","permalink":"https://blog.allenwu233.com/zh/about/","summary":"\u003ch2 id=\"欢迎来到又一座孤岛\"\u003e欢迎来到又一座“孤岛”\u003c/h2\u003e\n\u003cp\u003e我一直认为个人博客是一座孤岛。身为博主，勤于开拓\u003ca href=\"/zh/links\"\u003e友链\u003c/a\u003e的航线，将一座座孤岛连结起来，形成一张星罗密布的\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E5%9B%BE\"\u003e无向图\u003c/a\u003e。这样不仅方便互相学习交流，还能顺着大佬们的友链认识更多大佬，何乐而不为？\u003c/p\u003e\n\u003cp\u003e不管你是从搜索引擎过来的，还是顺着他人的友链找到我，欢迎多多评论，交流知识与哲思！\u003c/p\u003e\n\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003ebase64\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eb64decode\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMe\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Allen Wu\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehobbies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;jogging\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;harmonica\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;reading\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;programming\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efav_OS\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Arch Linux\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;LineageOS\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efav_programming_languages\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Python\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Rust\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efav_games\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Touhou\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Minecraft\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Outer Wilds\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eemail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eb64decode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;YWxsZW53dTIzM0BvdXRsb29rLmNvbQ==\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edecode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;utf-8\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Free_and_open-source_software\"\u003eFOSS\u003c/a\u003e 爱好者，自从用上了Arch Linux之后更是一发而不可收抬 \u003cdel\u003e（有一定程度的开源洁癖）\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e很爱折腾（从各种杂七杂八的\u003ca href=\"/zh/categories/%E6%95%99%E7%A8%8B/\"\u003e教程\u003c/a\u003e可见一斑）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"关于本站\"\u003e关于本站\u003c/h2\u003e\n\u003ch3 id=\"名称由来\"\u003e名称由来\u003c/h3\u003e\n\u003cp\u003e「逍遥」取自《庄子·内篇·逍遥游》，同时还很喜欢陶渊明笔下那种田园牧歌般的生活，于是为一个 Minecraft 原版生存存档命名为「逍遥乡」，寓意「心灵舒放之地」。本站也借用了这个名称\u003c/p\u003e\n\u003ch3 id=\"网站变迁\"\u003e网站变迁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e2022/08/16，建站，基于 Hugo 生成的静态博客，主题为 \u003ca href=\"https://github.com/CaiJimmy/hugo-theme-stack\"\u003eHugo Theme Stack\u003c/a\u003e 。部署在 Github Page 和 Netlify，最初站名为“Allen_Wu233\u0026rsquo;s Blog”\u003c/li\u003e\n\u003cli\u003e2023/05/24，购入个人域名，博客域名更新为：\u003ca href=\"blog.allenwu233.com\"\u003eblog.allenwu233.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e2024/05/xx - 2025/04/07，因 Netlify 出了点问题，SSL 证书过期，博客暂挂\u003c/li\u003e\n\u003cli\u003e2025/04/08，更新主题为 \u003ca href=\"https://github.com/adityatelange/hugo-PaperMod\"\u003eHugo PaperMod\u003c/a\u003e，站名改为“逍遥乡 | Allen\u0026rsquo;s World”，修复 SSL 证书问题，博客恢复正常访问\u003c/li\u003e\n\u003c/ul\u003e","title":"关于"},{"content":" 清絮 人生如逆旅，我亦是行人 lilydjwg 依云 百合仙子，Arch Linux CN 社区管理者之一 Yunyi\u0026rsquo;s Blog Little squirrel Hopping around 阮一峰 坚持更新网络日志，将博客精神体现得淋漓尽致 彼岸花开 欢迎！高洁而真诚的灵魂 又一条新航线 欢迎在评论区留下你的博客链接，最好按以下格式：\ntitle: # 你的名字 description: # 一句话个人或博客简介 website: # 个人网站 avatar: # 头像链接（可选） 博主信息，请随意添加：\ntitle: Allen Wu description: 天地与我并生，而万物与我为一。 website: https://blog.allenwu233.com avatar: https://blog.allenwu233.com/img/avatar.png favicon: https://blog.allenwu233.com/img/favicon/favicon-32x32.png 🍻欢迎友好交流！不要吝啬你的友链！\n","permalink":"https://blog.allenwu233.com/zh/links/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.linioi.com\"\u003e清絮\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e人生如逆旅，我亦是行人\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.lilydjwg.me/\"\u003elilydjwg 依云\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e百合仙子，Arch Linux CN 社区管理者之一\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.yunyitang.me/zh/\"\u003eYunyi\u0026rsquo;s Blog\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003eLittle squirrel Hopping around\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.ruanyifeng.com/\"\u003e阮一峰\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e坚持更新网络日志，将博客精神体现得淋漓尽致\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pxyfcywl.netlify.app\"\u003e彼岸花开\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e欢迎！高洁而真诚的灵魂\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"又一条新航线\"\u003e又一条新航线\u003c/h2\u003e\n\u003cp\u003e欢迎在评论区留下你的博客链接，最好按以下格式：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etitle: # 你的名字\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edescription: # 一句话个人或博客简介\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewebsite: # 个人网站\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eavatar: # 头像链接（可选）\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e博主信息，请随意添加：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etitle: Allen Wu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edescription: 天地与我并生，而万物与我为一。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewebsite: https://blog.allenwu233.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eavatar: https://blog.allenwu233.com/img/avatar.png\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efavicon: https://blog.allenwu233.com/img/favicon/favicon-32x32.png\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e🍻欢迎友好交流！不要吝啬你的友链！\u003c/p\u003e","title":"友链"}]