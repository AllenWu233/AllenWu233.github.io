<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据结构之美-二叉树 | 逍遥乡 | Allen's World</title>
<meta name=keywords content="数据结构,C++,Python,二叉树,算法"><meta name=description content="最近看什么都像二叉树（"><meta name=author content="Allen Wu"><link rel=canonical href=https://allenwu233.github.io/zh/posts/binary-tree/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://allenwu233.github.io/favicon/favicon/android-chrome-512x512.png><link rel=icon type=image/png sizes=16x16 href=https://allenwu233.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allenwu233.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://allenwu233.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://allenwu233.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://allenwu233.github.io/zh/posts/binary-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://allenwu233.github.io/zh/posts/binary-tree/"><meta property="og:site_name" content="逍遥乡 | Allen's World"><meta property="og:title" content="数据结构之美-二叉树"><meta property="og:description" content="最近看什么都像二叉树（"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-06T22:00:00+08:00"><meta property="article:modified_time" content="2022-11-25T21:33:00+08:00"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="C++"><meta property="article:tag" content="Python"><meta property="article:tag" content="二叉树"><meta property="article:tag" content="算法"><meta property="og:image" content="https://allenwu233.github.io/img/binary_tree.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://allenwu233.github.io/img/binary_tree.png"><meta name=twitter:title content="数据结构之美-二叉树"><meta name=twitter:description content="最近看什么都像二叉树（"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://allenwu233.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"数据结构之美-二叉树","item":"https://allenwu233.github.io/zh/posts/binary-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据结构之美-二叉树","name":"数据结构之美-二叉树","description":"最近看什么都像二叉树（","keywords":["数据结构","C++","Python","二叉树","算法"],"articleBody":"引言 - 二叉树是什么 在计算机科学中， 二叉树（Binary tree） 是每个结点最多只有两个分支（即不存在分支度大于2的结点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 与普通树不同，普通树的结点个数至少为1，而二叉树的结点个数可以为0；普通树结点的最大分支度没有限制，而二叉树结点的最大分支度为2；普通树的结点无左、右次序之分，而二叉树的结点有左、右次序之分。 ——From 中文维基百科·二叉树\n二叉树是非常重要的数据结构，其独特的结构使得它在搜索和处理数据方面有相当不错的表现\n二叉树的遍历 层次遍历（宽度优先遍历） 顾名思义，即按从上到下、从左到右的顺序遍历结点 以上图为例，遍历的顺序为1～15 这种方法叫 宽度优先遍历（Breadth-First Search, BFS）\n递归遍历（深度优先遍历） 博主认为二叉树的递归遍历是最为精彩的部分。理解其三种递归遍历方式，能一窥二叉树的结构之美\n对于一棵二叉树 T ，可以递归定义它的先序遍历、中序遍历和后序遍历，如下所示：\nPreOrder(T) = T的根结点 + PreOrder(T的左子树) + PreOrder(T的右子树) InOrder(T) = InOrder(T的左子树) + T的根结点 + InOrder(T的右结点) PostOrder(T) = PostOrder(T的左子树) + PostOrder(T的右子树) + T的根结点 这三种遍历都属于递归遍历，或者说 深度优先遍历（Depth-First Search, DFS） ，因为它总是优先往深处访问 ——From 刘汝佳《算法竞赛入门经典（第2版）》 还是以上图为例，来讲一下如何递归遍历： 要遍历整棵二叉树，首先把1,2,3看作一棵小二叉树来遍历，其中1为根，2,3为结点。遍历结点2或3时，再分别把2,4,5或3,6,7看作小二叉树来遍历，依次类推。具体遍历顺序由遍历的方式而定\n是不是很简单？在看下面的答案前，先试着写一下这三种遍历方式的顺序吧\n注：“根”——根结点，“左”——左子树，“右”——右子树 还是上图的例子：\n先序遍历 顺序：根--\u003e左--\u003e右 1 2 4 8 9 5 10 11 3 6 12 13 7 14 15\n中序遍历 顺序：左--\u003e根--\u003e右 8 4 9 2 10 5 11 1 12 6 13 3 14 7 15\n后序遍历 顺序：左--\u003e右--\u003e根 8 9 4 10 11 5 2 12 13 6 14 15 7 3 1\n实例：推导先序遍历 已知二叉树的中序遍历和后续遍历，如何推出这棵二叉树，以写出它的先序遍历？\n用Python风格伪代码来表示,[]代表列表（有序），{}代表集合（无序）\nInOrder = [7, 8, 11, 3, 5, 16, 12, 18] PostOrder = [8, 3, 11, 7, 16, 18, 12, 5] 由后序遍历的特点可知，最后一个字符5就是根，在中序遍历中找到5，把{7, 8, 11, 3}看作左子树，{16, 12, 18}看作右子树，构建一棵二叉树：\n5 / \\ {7, 8, 11, 3} {16, 12, 18} 接着再来看后序遍历，分别在[8, 3, 11, 7] , [16, 18, 12]中找出根，同理分别构建小二叉树：\n5 / \\ 7 12 \\ / \\ {8, 11, 3} 16 18 最后一步：\n5 / \\ 7 12 \\ / \\ 11 16 18 /\\ 8 3 于是我们可以得到它的先序遍历：\nPreOrder = [5, 7, 11, 8, 3, 12, 16, 18] 几道例题 推导先序遍历 即上面例子的代码实现 类似的题目：天依出去玩，以及参考答案\npre_order.py\npre_order, in_order, post_order = [], '', '' def read_list(): global pre_order, in_order, post_order in_order = input() post_order = input() pre_order = [] in_order = list(map(int, in_order.split())) post_order = list(map(int, post_order.split())) def build_pre(in_order, post_order): \"\"\"递归构建二叉树的先序遍历\"\"\" global pre_order # 直观地看到递归的步骤 print(\"in_order = \", in_order) print(\"post_order = \", post_order) print(\"pre_order = \", pre_order, \"\\n\") root = post_order[-1] pre_order.append(root) # 所谓先序遍历，只需在构建子树时记录下根节点即可 root_in_order = in_order.index(root) in_left = in_order[:root_in_order] in_right = in_order[root_in_order+1 : len(in_order)] post_left = post_order[:len(in_left)] post_right = post_order[len(in_left) : -1] if len(post_left): build_pre(in_left, post_left) if len(post_right): build_pre(in_right, post_right) while 1: try: read_list() except: break build_pre(in_order, post_order) print(\"PreOrder: \", end='') for i in pre_order: print(i, end=' ') print(\"\\n\") 输出示例：\n7 8 11 3 5 16 12 18 # 中序遍历 8 3 11 7 16 18 12 5 # 后序遍历 in_order = [7, 8, 11, 3, 5, 16, 12, 18] post_order = [8, 3, 11, 7, 16, 18, 12, 5] pre_order = [] # 读入数据 in_order = [7, 8, 11, 3] post_order = [8, 3, 11, 7] pre_order = [5] # 递归第一步，添加根节点5 in_order = [8, 11, 3] post_order = [8, 3, 11] pre_order = [5, 7] # 递归第二步，添加根节点7 in_order = [8] post_order = [8] pre_order = [5, 7, 11] in_order = [3] post_order = [3] pre_order = [5, 7, 11, 8] in_order = [16, 12, 18] post_order = [16, 18, 12] pre_order = [5, 7, 11, 8, 3] in_order = [16] post_order = [16] pre_order = [5, 7, 11, 8, 3, 12] in_order = [18] post_order = [18] pre_order = [5, 7, 11, 8, 3, 12, 16] PreOrder: 5 7 11 8 3 12 16 18 树的层次遍历（Trees on the level, UVa 122） 题目：\nvjudge PDF 分析：采用动态结构建树。代码出自紫书：\ntrees_on_the_level.cpp\n#include #include #include #include #include using namespace std; const int maxn = 256 + 10; // 节点类型 struct Node { bool have_value; int v; // 节点值 Node *left, *right; Node() : have_value(false), left(NULL), right(NULL){} // 构造函数 }; Node *root; // 二叉树的根节点 Node *newnode() { return new Node(); } bool failed; void addnode(int v, char *s) { int n = strlen(s); Node *u = root; // 从根节点往下走 for (int i = 0; i \u003c n; i++) { if (s[i] == 'L') { if (u-\u003eleft == NULL) u-\u003eleft = newnode(); // 节点不存在，建立新节点 u = u-\u003eleft; // 往右走 } else if (s[i] == 'R') { if (u-\u003eright == NULL) u-\u003eright = newnode(); u = u-\u003eright; } } if (u-\u003ehave_value) failed = true; u-\u003ev = v; u-\u003ehave_value = true; // 别忘了做标记 } void remove_tree(Node *u) { if (u == NULL) return; // 提前判断比较稳妥 remove_tree(u-\u003eleft); // 递归释放左子树空间 remove_tree(u-\u003eright); // 递归释放右子树空间 delete u; // 调用u的析构函数并释放u节点本身的内存 } char s[maxn]; bool read_input() { failed = false; remove_tree(root); // 释放上一棵二叉树的内存 root = newnode(); for (;;) { if (scanf(\"%s\", s) != 1) return false; if (!strcmp(s, \"()\")) break; int v; sscanf(\u0026s[1], \"%d\", \u0026v); addnode(v, strchr(s, ',') + 1); } return true; } bool bfs(vector\u003cint\u003e \u0026ans) // 宽度优先遍历(Breadth-First Search, BFS) { queue\u003cNode*\u003e q; ans.clear(); q.push(root); // 初始时只有一个根节点 while (!q.empty()) { Node *u = q.front(); q.pop(); if(!u-\u003ehave_value) return false; // 有节点没有被赋值过，表明输入有误 ans.push_back(u-\u003ev); // 增加到输出序列尾部 if (u-\u003eleft != NULL) q.push(u-\u003eleft); // 把左子节点（如果有）放进队列 if (u-\u003eright != NULL) q.push(u-\u003eright); // 把右子节点（如果有）放进队列 } return true; // 输入正确 } int main() { vector\u003cint\u003e ans; while(read_input()) { if(!bfs(ans)) failed = 1; if(failed) printf(\"not complete\\n\"); else { for(int i = 0; i \u003c ans.size(); i++) { if(i != 0) printf(\" \"); printf(\"%d\", ans[i]); } printf(\"\\n\"); } } return 0; } 小结：用结构体 + 指针实现二叉树。当然也可以用数组 + 下标来实现，但仍需具体情况具体分析\n二叉树的递归遍历（Trees, UVa548) 题目：\nvjudge PDF 分析：即已知二叉树的中序遍历和后序遍历，推出先序遍历。还是紫书：\ntrees.cpp\n#include #include #include #include using namespace std; const int maxv = 10000 + 10; int in_order[maxv], post_order[maxv], lch[maxv], rch[maxv]; int n; // 因为各个结点的权值各不相同且都是正整数，直接用权值作为结点编号 bool read_list(int *a) { string line; if (!getline(cin, line)) return false; stringstream ss(line); n = 0; int x; while (ss \u003e\u003e x) a[n++] = x; return n \u003e 0; } // 把in_order[L1..R1]和post_order[L2..R2]建成一棵二叉树，返回树根 int build(int L1, int R1, int L2, int R2) { if (L1 \u003e R1) return 0; // 空树 int root = post_order[R2]; int p = L1; while (in_order[p] != root) p++; int cnt = p - L1; // 左子树的结点个数 lch[root] = build(L1, p-1, L2, L2+cnt-1); rch[root] = build(p+1, R1, L2+cnt, R2-1); return root; } int best, best_sum; // 目前为止的最优解和对应的权和 void dfs(int u, int sum) // Deep First Search { sum += u; if (!lch[u] \u0026\u0026 !rch[u]) // 叶子 { if (sum \u003c best_sum || (sum == best_sum \u0026\u0026 u \u003c best)) { { best = u; best_sum = sum; } } if (lch[u]) dfs(lch[u], sum); if (rch[u]) dfs(rch[u], sum); } } int main() { while (read_list(in_order)) { read_list(post_order); build(0, n-1, 0, n-1); best_sum = 1000000000; dfs(post_order[n-1], 0); cout \u003c\u003c best \u003c\u003c \"\\n\"; } return 0; } 小结：难点在于理解利用数组lch和rch来储存节点的左右子树以及建树的过程。 建议自己画一下示意图帮助理解\n天平（Not so Mobile, UVa 839） 题目： PDF 分析：递归定义二叉树。还是紫书，代码相当精简、巧妙，值得一学：\nnot_so_mobile.cpp\n#include using namespace std; // 输入一个子天平，返回子天平是否平衡，参数W修改为子天平的总重量 bool solve(int \u0026W) { int W1, D1, W2, D2; bool b1 = true, b2 = true; cin \u003e\u003e W1 \u003e\u003e D1 \u003e\u003e W2 \u003e\u003e D2; if (!W1) b1 = solve(W1); if (!W2) b2 = solve(W2); W = W1 + W2; return b1 \u0026\u0026 b2 \u0026\u0026 (W1 * D1 == W2 * D2); // b1:左 b2:右 } int main() { int T, W; cin \u003e\u003e T; while (T--) { if (solve(W)) cout \u003c\u003c \"YES\\n\"; else cout \u003c\u003c \"NO\\n\"; if (T) cout \u003c\u003c \"\\n\"; } return 0; } not_so_mobile.py\ndef solve(W): b1, b2 = True, True W1, D1, W2, D2 = map(int, input().split()) if W1 == 0: b1 = solve(W1) if W2 == 0: b2 = solve(W2) W = W1 + W2 return b1 and b2 and (W1*D1 == W2*D2) W = 0 T = int(input()) while T \u003e 0: T -= 1 print(\"YES\") if solve(W) else print(\"No\") if T: print(\"\\n\") 似乎翻译成 Python 后可读性更强（\nPython类实现二叉树 面向对象真的很有意思，从无到有搓出一个功能完善的类 ，其兴奋感不亚于在mc中造出一台生电机器（\ntree.py\nclass Node(object): \"\"\"节点类\"\"\" def __init__(self, data=None, left_child=None, right_child=None): self.data = data self.left_child = left_child self.right_child = right_child class Tree(object): def __init__(self): self.root = Node() def rec_pre_order(self, node=None): \"\"\"递归实现前序遍历\"\"\" if node: print(node.data, end=\" \") self.rec_pre_order(node.left_child) self.rec_pre_order(node.right_child) def pre_order(self): \"\"\"非递归实现前序遍历\"\"\" if self.root: ls = [self.root] while ls: node = ls.pop() print(node.data, end=\" \") if node.right_child: ls.append(node.right_child) if node.left_child: ls.append(node.left_child) def pre_order2(self): \"\"\"非递归实现前序遍历\"\"\" stack = [] node = self.root while node or stack: while node: print(node.data, end=\" \") stack.append(node) node = node.left_child if stack: node = stack.pop() node = node.right_child def rec_in_order(self, node): \"\"\"递归实现中序遍历\"\"\" if node: self.rec_in_order(node.left_child) print(node.data, end=\" \") self.rec_in_order(node.right_child) def in_order(self): \"\"\"非递归实现中序遍历\"\"\" ls = [] node = self.root while node or len(ls): while node: ls.append(node) node = node.left_child if len(ls): node = ls.pop() print(node.data, end=\" \") node = node.right_child def in_order2(self): \"\"\"非递归实现中序遍历\"\"\" stack = [] node = self.root while node: while node: if node.right_child: stack.append(node.right_child) stack.append(node) node = node.left_child node = stack.pop() while stack and (not node.right_child): print(node.data, end=\" \") node = stack.pop() print(node.data, end=\" \") if stack: node = stack.pop() else: node = None def rec_post_order(self, node): \"\"\"递归实现后序遍历\"\"\" if node: self.rec_post_order(node.left_child) self.rec_post_order(node.right_child) print(node.data, end=\" \") def post_order(self, node): \"\"\"非递归实现后序遍历\"\"\" q = node ls = [] while node: while node.left_child: ls.append(node) node = node.left_child while node and (node.right_child is None or node.right_child == q): print(node.data, end=\" \") q = node if not ls: return node = ls.pop() ls.append(node) node = node.right_child def get_depth(self): \"\"\"计算树的深度，递归树的左右节点,取值大的深度\"\"\" def _depth(node): if not node: return 0 else: left_depth = _depth(node.left_child) right_depth = _depth(node.right_child) if left_depth \u003e right_depth: return left_depth + 1 else: return right_depth + 1 return _depth(self.root) def get_leaves(self, node): \"\"\"递归输出所有叶子节点\"\"\" if node: if not node.left_child and not node.right_child: print(node.data, end=\" \") else: self.get_leaves(node.left_child) self.get_leaves(node.right_child) if __name__ == '__main__': tree = Tree() tree.root = Node('A') tree.root.left_child = Node('B') tree.root.right_child = Node('C') tree.root.left_child.left_child = Node('D') tree.root.left_child.right_child = Node('E') tree.root.left_child.right_child.right_child = Node('F') tree.root.left_child.left_child.right_child = Node('G') print(\"\"\" A | ------------- | | B C | ------------- | | D E | | ------- ------- | | | | (None) G (None) F \"\"\") print(\"#先序遍历\") print(\"递归：\") tree.rec_pre_order(tree.root) print(\"\\n非递归1：\") tree.pre_order() print(\"\\n非递归2：\") tree.pre_order2() print(\"\\n\\n#中序遍历\") print(\"递归：\") tree.rec_in_order(tree.root) print(\"\\n非递归1：\") tree.in_order() print(\"\\n非递归2：\") tree.in_order2() print(\"\\n\\n#后序遍历\") print(\"递归：\") tree.rec_post_order(tree.root) print(\"\\n非递归：\") tree.post_order(tree.root) print(\"\\n\\n二叉树的深度为：\", tree.get_depth()) print(\"\\n叶子节点：\", end=\"\") tree.get_leaves(tree.root) 二叉查找树 （先挖个坑，以后回来更新）\n参考文献 中文维基百科·二叉树 刘汝佳《算法竞赛入门经典（第2版） ","wordCount":"1496","inLanguage":"zh","image":"https://allenwu233.github.io/img/binary_tree.png","datePublished":"2022-11-06T22:00:00+08:00","dateModified":"2022-11-25T21:33:00+08:00","author":{"@type":"Person","name":"Allen Wu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://allenwu233.github.io/zh/posts/binary-tree/"},"publisher":{"@type":"Organization","name":"逍遥乡 | Allen's World","logo":{"@type":"ImageObject","url":"https://allenwu233.github.io/favicon/favicon/android-chrome-512x512.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://allenwu233.github.io/zh/ accesskey=h title="逍遥乡 (Alt + H)"><img src=https://allenwu233.github.io/img/avatar.png alt aria-label=logo height=35>逍遥乡</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://allenwu233.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://allenwu233.github.io/zh/about/ title=📋关于><span>📋关于</span></a></li><li><a href=https://allenwu233.github.io/zh/links/ title=🔗友链><span>🔗友链</span></a></li><li><a href=https://allenwu233.github.io/zh/categories/ title=📔类别><span>📔类别</span></a></li><li><a href=https://allenwu233.github.io/zh/archives/ title=📦归档><span>📦归档</span></a></li><li><a href=https://allenwu233.github.io/zh/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://allenwu233.github.io/zh/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://allenwu233.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://allenwu233.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">数据结构之美-二叉树</h1><div class=post-description>最近看什么都像二叉树（</div><div class=post-meta><span title='2022-11-06 22:00:00 +0800 +0800'>2022/11/06</span>&nbsp;·&nbsp;Allen Wu</div></header><figure class=entry-cover><img loading=eager src=https://allenwu233.github.io/img/binary_tree.png alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#引言---二叉树是什么>引言 - 二叉树是什么</a></li><li><a href=#二叉树的遍历>二叉树的遍历</a><ul><li><a href=#层次遍历宽度优先遍历>层次遍历（宽度优先遍历）</a></li><li><a href=#递归遍历深度优先遍历>递归遍历（深度优先遍历）</a></li><li><a href=#几道例题>几道例题</a></li></ul></li><li><a href=#python类实现二叉树>Python类实现二叉树</a></li><li><a href=#二叉查找树>二叉查找树</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></details></div><div class=post-content><h2 id=引言---二叉树是什么>引言 - 二叉树是什么<a hidden class=anchor aria-hidden=true href=#引言---二叉树是什么>#</a></h2><blockquote><p>在计算机科学中， <strong>二叉树（Binary tree）</strong> 是每个结点最多只有两个分支（即不存在分支度大于2的结点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。
与普通树不同，普通树的结点个数至少为1，而二叉树的结点个数可以为0；普通树结点的最大分支度没有限制，而二叉树结点的最大分支度为2；普通树的结点无左、右次序之分，而二叉树的结点有左、右次序之分。
——From <a href=https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91>中文维基百科·二叉树</a></p></blockquote><p>二叉树是非常重要的数据结构，其独特的结构使得它在搜索和处理数据方面有相当不错的表现</p><h2 id=二叉树的遍历>二叉树的遍历<a hidden class=anchor aria-hidden=true href=#二叉树的遍历>#</a></h2><h3 id=层次遍历宽度优先遍历>层次遍历（宽度优先遍历）<a hidden class=anchor aria-hidden=true href=#层次遍历宽度优先遍历>#</a></h3><p>顾名思义，即按从上到下、从左到右的顺序遍历结点
以上图为例，遍历的顺序为<code>1～15</code>
这种方法叫 <strong>宽度优先遍历（Breadth-First Search, BFS）</strong></p><h3 id=递归遍历深度优先遍历>递归遍历（深度优先遍历）<a hidden class=anchor aria-hidden=true href=#递归遍历深度优先遍历>#</a></h3><p>博主认为二叉树的递归遍历是<em>最为精彩</em>的部分。理解其三种递归遍历方式，能一窥二叉树的结构之美</p><blockquote><p>对于一棵二叉树 T ，可以递归定义它的先序遍历、中序遍历和后序遍历，如下所示：</p></blockquote><ul><li>PreOrder(T) = T的根结点 + PreOrder(T的左子树) + PreOrder(T的右子树)</li><li>InOrder(T) = InOrder(T的左子树) + T的根结点 + InOrder(T的右结点)</li><li>PostOrder(T) = PostOrder(T的左子树) + PostOrder(T的右子树) + T的根结点
这三种遍历都属于递归遍历，或者说 <strong>深度优先遍历（Depth-First Search, DFS）</strong> ，因为它总是优先往深处访问
——From 刘汝佳《算法竞赛入门经典（第2版）》</li></ul><p>还是以上图为例，来讲一下如何递归遍历：
要遍历整棵二叉树，首先把<code>1,2,3</code>看作一棵小二叉树来遍历，其中<code>1</code>为根，<code>2,3</code>为结点。遍历结点<code>2</code>或<code>3</code>时，再分别把<code>2,4,5</code>或<code>3,6,7</code>看作小二叉树来遍历，依次类推。具体遍历顺序由遍历的方式而定</p><p>是不是很简单？在看下面的答案前，先试着写一下这三种遍历方式的顺序吧</p><blockquote><p>注：“根”——根结点，“左”——左子树，“右”——右子树
还是上图的例子：</p></blockquote><h4 id=先序遍历>先序遍历<a hidden class=anchor aria-hidden=true href=#先序遍历>#</a></h4><p>顺序：<code>根-->左-->右</code>
<code>1 2 4 8 9 5 10 11 3 6 12 13 7 14 15</code></p><h4 id=中序遍历>中序遍历<a hidden class=anchor aria-hidden=true href=#中序遍历>#</a></h4><p>顺序：<code>左-->根-->右</code>
<code>8 4 9 2 10 5 11 1 12 6 13 3 14 7 15</code></p><h4 id=后序遍历>后序遍历<a hidden class=anchor aria-hidden=true href=#后序遍历>#</a></h4><p>顺序：<code>左-->右-->根</code>
<code>8 9 4 10 11 5 2 12 13 6 14 15 7 3 1</code></p><h4 id=实例推导先序遍历>实例：推导先序遍历<a hidden class=anchor aria-hidden=true href=#实例推导先序遍历>#</a></h4><blockquote><p>已知二叉树的中序遍历和后续遍历，如何推出这棵二叉树，以写出它的先序遍历？</p></blockquote><p>用Python风格伪代码来表示,<code>[]</code>代表列表（有序），<code>{}</code>代表集合（无序）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>InOrder</span>   <span class=o>=</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>PostOrder</span> <span class=o>=</span> <span class=p>[</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span></code></pre></div><p>由后序遍历的特点可知，最后一个字符<code>5</code>就是根，在中序遍历中找到<code>5</code>，把<code>{7, 8, 11, 3}</code>看作左子树，<code>{16, 12, 18}</code>看作右子树，构建一棵二叉树：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>              5
</span></span><span class=line><span class=cl>             / \
</span></span><span class=line><span class=cl>{7, 8, 11, 3}   {16, 12, 18}
</span></span></code></pre></div><p>接着再来看后序遍历，分别在<code>[8, 3, 11, 7]</code> , <code>[16, 18, 12]</code>中找出根，同理分别构建小二叉树：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>              5
</span></span><span class=line><span class=cl>             / \
</span></span><span class=line><span class=cl>            7   12
</span></span><span class=line><span class=cl>            \   / \
</span></span><span class=line><span class=cl>    {8, 11, 3} 16 18
</span></span></code></pre></div><p>最后一步：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>              5
</span></span><span class=line><span class=cl>             / \
</span></span><span class=line><span class=cl>            7   12
</span></span><span class=line><span class=cl>            \   / \
</span></span><span class=line><span class=cl>            11 16 18
</span></span><span class=line><span class=cl>            /\
</span></span><span class=line><span class=cl>           8  3
</span></span></code></pre></div><p>于是我们可以得到它的先序遍历：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>PreOrder</span> <span class=o>=</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>18</span><span class=p>]</span>
</span></span></code></pre></div><h3 id=几道例题>几道例题<a hidden class=anchor aria-hidden=true href=#几道例题>#</a></h3><h4 id=推导先序遍历>推导先序遍历<a hidden class=anchor aria-hidden=true href=#推导先序遍历>#</a></h4><p>即上面例子的代码实现
类似的题目：<a href=https://ac.nowcoder.com/acm/problem/244280>天依出去玩</a>，以及<a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=55005430&amp;returnHomeType=1&amp;uid=807489743">参考答案</a></p><blockquote><p>pre_order.py</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>pre_order</span><span class=p>,</span> <span class=n>in_order</span><span class=p>,</span> <span class=n>post_order</span> <span class=o>=</span> <span class=p>[],</span> <span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_list</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>pre_order</span><span class=p>,</span> <span class=n>in_order</span><span class=p>,</span> <span class=n>post_order</span>
</span></span><span class=line><span class=cl>    <span class=n>in_order</span> <span class=o>=</span> <span class=nb>input</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>post_order</span> <span class=o>=</span> <span class=nb>input</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>pre_order</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>in_order</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>in_order</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=n>post_order</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>post_order</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>build_pre</span><span class=p>(</span><span class=n>in_order</span><span class=p>,</span> <span class=n>post_order</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;递归构建二叉树的先序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>pre_order</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 直观地看到递归的步骤</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;in_order   = &#34;</span><span class=p>,</span> <span class=n>in_order</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;post_order = &#34;</span><span class=p>,</span> <span class=n>post_order</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;pre_order  = &#34;</span><span class=p>,</span> <span class=n>pre_order</span><span class=p>,</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>root</span> <span class=o>=</span> <span class=n>post_order</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>pre_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>  <span class=c1># 所谓先序遍历，只需在构建子树时记录下根节点即可</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>root_in_order</span> <span class=o>=</span> <span class=n>in_order</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>in_left</span> <span class=o>=</span> <span class=n>in_order</span><span class=p>[:</span><span class=n>root_in_order</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>in_right</span> <span class=o>=</span> <span class=n>in_order</span><span class=p>[</span><span class=n>root_in_order</span><span class=o>+</span><span class=mi>1</span> <span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>in_order</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>post_left</span> <span class=o>=</span> <span class=n>post_order</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=n>in_left</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>post_right</span> <span class=o>=</span> <span class=n>post_order</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>in_left</span><span class=p>)</span> <span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>post_left</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>build_pre</span><span class=p>(</span><span class=n>in_left</span><span class=p>,</span> <span class=n>post_left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>post_right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>build_pre</span><span class=p>(</span><span class=n>in_right</span><span class=p>,</span> <span class=n>post_right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>read_list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=n>build_pre</span><span class=p>(</span><span class=n>in_order</span><span class=p>,</span> <span class=n>post_order</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;PreOrder: &#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>pre_order</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><blockquote><p>输出示例：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=mi>7</span> <span class=mi>8</span> <span class=mi>11</span> <span class=mi>3</span> <span class=mi>5</span> <span class=mi>16</span> <span class=mi>12</span> <span class=mi>18</span>  <span class=c1># 中序遍历</span>
</span></span><span class=line><span class=cl><span class=mi>8</span> <span class=mi>3</span> <span class=mi>11</span> <span class=mi>7</span> <span class=mi>16</span> <span class=mi>18</span> <span class=mi>12</span> <span class=mi>5</span>  <span class=c1># 后序遍历</span>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[]</span>  <span class=c1># 读入数据</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>7</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>]</span>  <span class=c1># 递归第一步，添加根节点5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>11</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>]</span>  <span class=c1># 递归第二步，添加根节点7</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>16</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>16</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>12</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>16</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>16</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>12</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>in_order</span>   <span class=o>=</span>  <span class=p>[</span><span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>post_order</span> <span class=o>=</span>  <span class=p>[</span><span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pre_order</span>  <span class=o>=</span>  <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>16</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PreOrder</span><span class=p>:</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>11</span> <span class=mi>8</span> <span class=mi>3</span> <span class=mi>12</span> <span class=mi>16</span> <span class=mi>18</span>
</span></span></code></pre></div><h4 id=树的层次遍历trees-on-the-level-uva-122>树的层次遍历（Trees on the level, UVa 122）<a hidden class=anchor aria-hidden=true href=#树的层次遍历trees-on-the-level-uva-122>#</a></h4><p>题目：</p><ul><li><a href=https://vjudge.net/problem/UVA-122>vjudge</a></li><li><a href=https://github.com/AllenWu233/algorithm_study/blob/main/chapter_6/uva122.pdf>PDF</a></li></ul><p>分析：采用动态结构建树。代码出自紫书：</p><blockquote><p>trees_on_the_level.cpp</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include&lt;cstdio&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;cstdlib&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;cstring&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;vector&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;queue&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>maxn</span> <span class=o>=</span> <span class=mi>256</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 节点类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>have_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>v</span><span class=p>;</span>  <span class=c1>// 节点值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=p>()</span> <span class=o>:</span> <span class=n>have_value</span><span class=p>(</span><span class=nb>false</span><span class=p>),</span> <span class=n>left</span><span class=p>(</span><span class=nb>NULL</span><span class=p>),</span> <span class=n>right</span><span class=p>(</span><span class=nb>NULL</span><span class=p>){}</span>  <span class=c1>// 构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>  <span class=c1>// 二叉树的根节点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=nf>newnode</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=k>new</span> <span class=n>Node</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>failed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>addnode</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>u</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>  <span class=c1>// 从根节点往下走
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;L&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>newnode</span><span class=p>();</span>  <span class=c1>// 节点不存在，建立新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>u</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>                               <span class=c1>// 往右走
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;R&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>newnode</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>u</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>have_value</span><span class=p>)</span> <span class=n>failed</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u</span><span class=o>-&gt;</span><span class=n>v</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u</span><span class=o>-&gt;</span><span class=n>have_value</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>  <span class=c1>// 别忘了做标记
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>remove_tree</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>  <span class=c1>// 提前判断比较稳妥
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>remove_tree</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>   <span class=c1>// 递归释放左子树空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>remove_tree</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>  <span class=c1>// 递归释放右子树空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=n>u</span><span class=p>;</span>  <span class=c1>// 调用u的析构函数并释放u节点本身的内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>[</span><span class=n>maxn</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>read_input</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>failed</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>remove_tree</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>  <span class=c1>// 释放上一棵二叉树的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>root</span> <span class=o>=</span> <span class=n>newnode</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>strcmp</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=s>&#34;()&#34;</span><span class=p>))</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sscanf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>addnode</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>strchr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=sc>&#39;,&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>bfs</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>ans</span><span class=p>)</span>  <span class=c1>// 宽度优先遍历(Breadth-First Search, BFS)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>*&gt;</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ans</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>  <span class=c1>// 初始时只有一个根节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=o>*</span><span class=n>u</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>();</span> <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>have_value</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>  <span class=c1>// 有节点没有被赋值过，表明输入有误
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ans</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>v</span><span class=p>);</span>  <span class=c1>// 增加到输出序列尾部
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>  <span class=c1>// 把左子节点（如果有）放进队列
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>  <span class=c1>// 把右子节点（如果有）放进队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>  <span class=c1>// 输入正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>read_input</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>bfs</span><span class=p>(</span><span class=n>ans</span><span class=p>))</span> <span class=n>failed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>failed</span><span class=p>)</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;not complete</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ans</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34; &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>小结：用<code>结构体 + 指针</code>实现二叉树。当然也可以用<code>数组 + 下标</code>来实现，但仍需具体情况具体分析</p><h4 id=二叉树的递归遍历trees-uva548>二叉树的递归遍历（Trees, UVa548)<a hidden class=anchor aria-hidden=true href=#二叉树的递归遍历trees-uva548>#</a></h4><p>题目：</p><ul><li><a href=https://vjudge.net/problem/UVA-548>vjudge</a></li><li><a href=https://github.com/AllenWu233/algorithm_study/blob/main/chapter_6/uva548.pdf>PDF</a></li></ul><p>分析：即已知二叉树的中序遍历和后序遍历，推出先序遍历。还是紫书：</p><blockquote><p>trees.cpp</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sstream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>maxv</span> <span class=o>=</span> <span class=mi>10000</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>in_order</span><span class=p>[</span><span class=n>maxv</span><span class=p>],</span> <span class=n>post_order</span><span class=p>[</span><span class=n>maxv</span><span class=p>],</span> <span class=n>lch</span><span class=p>[</span><span class=n>maxv</span><span class=p>],</span> <span class=n>rch</span><span class=p>[</span><span class=n>maxv</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因为各个结点的权值各不相同且都是正整数，直接用权值作为结点编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>read_list</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>getline</span><span class=p>(</span><span class=n>cin</span><span class=p>,</span> <span class=n>line</span><span class=p>))</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>stringstream</span> <span class=n>ss</span><span class=p>(</span><span class=n>line</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>ss</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>)</span> <span class=n>a</span><span class=p>[</span><span class=n>n</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 把in_order[L1..R1]和post_order[L2..R2]建成一棵二叉树，返回树根
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>build</span><span class=p>(</span><span class=kt>int</span> <span class=n>L1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>R1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>L2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>R2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>L1</span> <span class=o>&gt;</span> <span class=n>R1</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// 空树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>root</span> <span class=o>=</span> <span class=n>post_order</span><span class=p>[</span><span class=n>R2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=n>L1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>in_order</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>!=</span> <span class=n>root</span><span class=p>)</span> <span class=n>p</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=n>p</span> <span class=o>-</span> <span class=n>L1</span><span class=p>;</span>  <span class=c1>// 左子树的结点个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lch</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>build</span><span class=p>(</span><span class=n>L1</span><span class=p>,</span> <span class=n>p</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>L2</span><span class=p>,</span> <span class=n>L2</span><span class=o>+</span><span class=n>cnt</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rch</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>build</span><span class=p>(</span><span class=n>p</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=n>L2</span><span class=o>+</span><span class=n>cnt</span><span class=p>,</span> <span class=n>R2</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>best</span><span class=p>,</span> <span class=n>best_sum</span><span class=p>;</span>  <span class=c1>// 目前为止的最优解和对应的权和
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>dfs</span><span class=p>(</span><span class=kt>int</span> <span class=n>u</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sum</span><span class=p>)</span>  <span class=c1>// Deep First Search
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span> <span class=o>+=</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lch</span><span class=p>[</span><span class=n>u</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>rch</span><span class=p>[</span><span class=n>u</span><span class=p>])</span>  <span class=c1>// 叶子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>&lt;</span> <span class=n>best_sum</span> <span class=o>||</span> <span class=p>(</span><span class=n>sum</span> <span class=o>==</span> <span class=n>best_sum</span> <span class=o>&amp;&amp;</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>best</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span> <span class=n>best</span> <span class=o>=</span> <span class=n>u</span><span class=p>;</span> <span class=n>best_sum</span> <span class=o>=</span> <span class=n>sum</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>lch</span><span class=p>[</span><span class=n>u</span><span class=p>])</span> <span class=n>dfs</span><span class=p>(</span><span class=n>lch</span><span class=p>[</span><span class=n>u</span><span class=p>],</span> <span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>rch</span><span class=p>[</span><span class=n>u</span><span class=p>])</span> <span class=n>dfs</span><span class=p>(</span><span class=n>rch</span><span class=p>[</span><span class=n>u</span><span class=p>],</span> <span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>read_list</span><span class=p>(</span><span class=n>in_order</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>read_list</span><span class=p>(</span><span class=n>post_order</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>build</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>best_sum</span> <span class=o>=</span> <span class=mi>1000000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>post_order</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>best</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>小结：难点在于理解利用数组<code>lch</code>和<code>rch</code>来储存节点的左右子树以及建树的过程。
建议自己画一下示意图帮助理解</p><h4 id=天平not-so-mobile-uva-839>天平（Not so Mobile, UVa 839）<a hidden class=anchor aria-hidden=true href=#天平not-so-mobile-uva-839>#</a></h4><p>题目： <a href=https://github.com/AllenWu233/algorithm_study/blob/main/chapter_6/uva839.pdf>PDF</a>
分析：递归定义二叉树。还是紫书，代码相当精简、巧妙，值得一学：</p><blockquote><p>not_so_mobile.cpp</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输入一个子天平，返回子天平是否平衡，参数W修改为子天平的总重量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>solve</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>W</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>W1</span><span class=p>,</span> <span class=n>D1</span><span class=p>,</span> <span class=n>W2</span><span class=p>,</span> <span class=n>D2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>b1</span> <span class=o>=</span> <span class=nb>true</span><span class=p>,</span> <span class=n>b2</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>W1</span> <span class=o>&gt;&gt;</span> <span class=n>D1</span> <span class=o>&gt;&gt;</span> <span class=n>W2</span> <span class=o>&gt;&gt;</span> <span class=n>D2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>W1</span><span class=p>)</span> <span class=n>b1</span> <span class=o>=</span> <span class=n>solve</span><span class=p>(</span><span class=n>W1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>W2</span><span class=p>)</span> <span class=n>b2</span> <span class=o>=</span> <span class=n>solve</span><span class=p>(</span><span class=n>W2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>W</span> <span class=o>=</span> <span class=n>W1</span> <span class=o>+</span> <span class=n>W2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b1</span> <span class=o>&amp;&amp;</span> <span class=n>b2</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>W1</span> <span class=o>*</span> <span class=n>D1</span> <span class=o>==</span> <span class=n>W2</span> <span class=o>*</span> <span class=n>D2</span><span class=p>);</span>  <span class=c1>// b1:左 b2:右
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>T</span><span class=p>,</span> <span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>T</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>solve</span><span class=p>(</span><span class=n>W</span><span class=p>))</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;YES</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=k>else</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;NO</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>not_so_mobile.py</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve</span><span class=p>(</span><span class=n>W</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>b1</span><span class=p>,</span> <span class=n>b2</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=n>W1</span><span class=p>,</span> <span class=n>D1</span><span class=p>,</span> <span class=n>W2</span><span class=p>,</span> <span class=n>D2</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>W1</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>b1</span> <span class=o>=</span> <span class=n>solve</span><span class=p>(</span><span class=n>W1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>W2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>b2</span> <span class=o>=</span> <span class=n>solve</span><span class=p>(</span><span class=n>W2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>W</span> <span class=o>=</span> <span class=n>W1</span> <span class=o>+</span> <span class=n>W2</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b1</span> <span class=ow>and</span> <span class=n>b2</span> <span class=ow>and</span> <span class=p>(</span><span class=n>W1</span><span class=o>*</span><span class=n>D1</span> <span class=o>==</span> <span class=n>W2</span><span class=o>*</span><span class=n>D2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>W</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>T</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;YES&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>solve</span><span class=p>(</span><span class=n>W</span><span class=p>)</span> <span class=k>else</span> <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;No&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>T</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p><del>似乎翻译成 Python 后可读性更强（</del></p><h2 id=python类实现二叉树>Python类实现二叉树<a hidden class=anchor aria-hidden=true href=#python类实现二叉树>#</a></h2><p>面向对象真的很有意思，从无到有搓出一个功能完善的类 <del>，其兴奋感不亚于在mc中造出一台生电机器（</del></p><blockquote><p>tree.py</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;节点类&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>left_child</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right_child</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left_child</span> <span class=o>=</span> <span class=n>left_child</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right_child</span> <span class=o>=</span> <span class=n>right_child</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Tree</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>Node</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>rec_pre_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;递归实现前序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_pre_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_pre_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pre_order</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;非递归实现前序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>ls</span> <span class=o>=</span> <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>ls</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>ls</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>ls</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>ls</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pre_order2</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;非递归实现前序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>rec_in_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;递归实现中序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_in_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_in_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>in_order</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;非递归实现中序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>ls</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>node</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>ls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>ls</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>ls</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>in_order2</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;非递归实现中序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>stack</span> <span class=ow>and</span> <span class=p>(</span><span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>rec_post_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;递归实现后序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_post_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rec_post_order</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>post_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;非递归实现后序遍历&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=n>ls</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>ls</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>node</span> <span class=ow>and</span> <span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>or</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span> <span class=o>==</span> <span class=n>q</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>ls</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>ls</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>ls</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_depth</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;计算树的深度，递归树的左右节点,取值大的深度&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>_depth</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>left_depth</span> <span class=o>=</span> <span class=n>_depth</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>right_depth</span> <span class=o>=</span> <span class=n>_depth</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>left_depth</span> <span class=o>&gt;</span> <span class=n>right_depth</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>left_depth</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>right_depth</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>_depth</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_leaves</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;递归输出所有叶子节点&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>left_child</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>get_leaves</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>get_leaves</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right_child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span> <span class=o>=</span> <span class=n>Tree</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>left_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>right_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>left_child</span><span class=o>.</span><span class=n>left_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;D&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>left_child</span><span class=o>.</span><span class=n>right_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;E&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>left_child</span><span class=o>.</span><span class=n>right_child</span><span class=o>.</span><span class=n>right_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>left_child</span><span class=o>.</span><span class=n>left_child</span><span class=o>.</span><span class=n>right_child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;G&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                 A
</span></span></span><span class=line><span class=cl><span class=s2>                 |
</span></span></span><span class=line><span class=cl><span class=s2>           -------------
</span></span></span><span class=line><span class=cl><span class=s2>           |           |
</span></span></span><span class=line><span class=cl><span class=s2>           B           C
</span></span></span><span class=line><span class=cl><span class=s2>           |
</span></span></span><span class=line><span class=cl><span class=s2>     -------------
</span></span></span><span class=line><span class=cl><span class=s2>     |           |
</span></span></span><span class=line><span class=cl><span class=s2>     D           E
</span></span></span><span class=line><span class=cl><span class=s2>     |           |
</span></span></span><span class=line><span class=cl><span class=s2>  -------     -------
</span></span></span><span class=line><span class=cl><span class=s2>  |     |     |     |
</span></span></span><span class=line><span class=cl><span class=s2>(None)  G   (None)  F
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;#先序遍历&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;递归：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>rec_pre_order</span><span class=p>(</span><span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>非递归1：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>pre_order</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>非递归2：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>pre_order2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n\n</span><span class=s2>#中序遍历&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;递归：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>rec_in_order</span><span class=p>(</span><span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>非递归1：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>in_order</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>非递归2：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>in_order2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n\n</span><span class=s2>#后序遍历&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;递归：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>rec_post_order</span><span class=p>(</span><span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>非递归：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>post_order</span><span class=p>(</span><span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n\n</span><span class=s2>二叉树的深度为：&#34;</span><span class=p>,</span> <span class=n>tree</span><span class=o>.</span><span class=n>get_depth</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>叶子节点：&#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=o>.</span><span class=n>get_leaves</span><span class=p>(</span><span class=n>tree</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=二叉查找树>二叉查找树<a hidden class=anchor aria-hidden=true href=#二叉查找树>#</a></h2><p><del>（先挖个坑，以后回来更新）</del></p><p><img alt=640 loading=lazy src=/img/640.jpg></p><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><ol><li><a href=https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91>中文维基百科·二叉树</a></li><li>刘汝佳《算法竞赛入门经典（第2版）</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://allenwu233.github.io/zh/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=https://allenwu233.github.io/zh/tags/c++/>C++</a></li><li><a href=https://allenwu233.github.io/zh/tags/python/>Python</a></li><li><a href=https://allenwu233.github.io/zh/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/>二叉树</a></li><li><a href=https://allenwu233.github.io/zh/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://allenwu233.github.io/zh/posts/little-reimu/><span class=title>« 上一页</span><br><span>记忆、爱与救赎</span>
</a><a class=next href=https://allenwu233.github.io/zh/posts/stack/><span class=title>下一页 »</span><br><span>数据结构初见-栈</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=AllenWu233/AllenWu233.github.io data-repo-id=R_kgDOOUVoCw data-category=Announcements data-category-id=DIC_kwDOOUVoC84Co2ps data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://allenwu233.github.io/zh/>逍遥乡 | Allen's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>