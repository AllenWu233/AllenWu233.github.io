<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Allen的动态规划基础 | 逍遥乡 | Allen's World</title><meta name=keywords content="算法,ACM,DP"><meta name=description content="状态和状态转移方程"><meta name=author content="Allen Wu"><link rel=canonical href=https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.allenwu233.com/favicon/favicon/android-chrome-512x512.png><link rel=icon type=image/png sizes=16x16 href=https://blog.allenwu233.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.allenwu233.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.allenwu233.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://blog.allenwu233.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/"><meta property="og:site_name" content="逍遥乡 | Allen's World"><meta property="og:title" content="Allen的动态规划基础"><meta property="og:description" content="状态和状态转移方程"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-13T21:58:57+08:00"><meta property="article:modified_time" content="2023-03-13T21:58:57+08:00"><meta property="article:tag" content="算法"><meta property="article:tag" content="ACM"><meta property="article:tag" content="DP"><meta property="og:image" content="https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/cover.jpg"><meta name=twitter:title content="Allen的动态规划基础"><meta name=twitter:description content="状态和状态转移方程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.allenwu233.com/zh/posts/"},{"@type":"ListItem","position":2,"name":"Allen的动态规划基础","item":"https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Allen的动态规划基础","name":"Allen的动态规划基础","description":"状态和状态转移方程","keywords":["算法","ACM","DP"],"articleBody":" 来点BGM\n引言 概念 动态规划（英语：Dynamic programming，简称DP） 是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。\n适用情况 最优子结构性质。 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。\n无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。\n子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。\n——From 维基百科·动态规划\n动态规划其实不是一种具体的算法，而是解决问题的思想和方法。简单来说，动态规划就是把问题分解成一个个子问题，通过求子问题的最优解得到全局最优解（这就是所谓的最优子结构（optimal substructure））\n正文 状态和状态转移方程 动态规划的核心是状态和状态转移方程\n动态规划中状态就是子问题的结果，而本阶段的状态往往是上一阶段状态和上一阶段决策的结果，描述这种前后阶段关系的方程，就是状态转移方程\n如 $ f(i, j) = \\max \\{f(i, k) , f(k+1, j)+1\\} $ 就是一个状态转移方程\n来看看几道例题\n数字三角形 题目：有一个由非负整数组成的三角形，第一行只有一个数。从第一行的数开始，每次可以往左下或右下走一格，直到走到最下行，把沿途经过的数加起来，求怎么走才能使得数字之和最大？\n数字三角形如下所示：\n1 / \\ 3 2 / \\ / \\ 4 10 1 / \\ / \\ / \\ 4 3 2 20 分析 贪心法？ 按照贪心法，求出的路径为：1 --\u003e 3 --\u003e 10 --\u003e 3\n而实际最大和的路径为：1 --\u003e 2 --\u003e 1 --\u003e 20\n显然，贪心法不能保证全局最优解\n回溯法？ 每一个结点都有两种选择，如果用回溯法求出所有可能的的路径，就能找到最优解\n然而回溯法的效率太低：一个$ n $层的三角形有 $ 2^{n-1} $ 条路线，复杂度之大让人无法接受\n可以看出，这是一个动态的决策问题——每次可以选择往左下走或往右下走，由此引出我们今天的主角——动态规划\n动态规划 假设用下三角矩阵（主对角线上方所有元素为0的二维数组）a、d分别存储数字三角形和d[i][j]出发路径的最大和\n根据动态规划的思想，求第一层（d[1][1]，即整个数字三角形路径的最大和）出发的最大和，得先求出从第二层出发的最大和；求第二层出发的最大和，得先求出从第三层出发的最大和……由此类推，我们可以把整个问题分解成多个子问题。显然，这道题符合动态规划的条件：\n最优子结构性质。求出第n层的最优解，就能求出第n-1层的最优解，子问题的最优解最终保证整个问题的最优解 无后效性。第n层的最优解一旦确定，就不受前面层的影响 子问题重叠性质。比如要计算d[2][1],就要先计算d[3][1]和d[3][2]；而要计算d[2][2],也要先计算d[3][2]。由此可见问题的解答树大量重叠，正是动态规划的用武之地 状态转移方程如下\n$ d(i, j) = a(i, j) + max\\{d(i+1, j), d(i+1, j+1)\\} $\n下面介绍两种基本的动态规划写法\n方法一：记忆化搜索 直接递归的写法是可以的，但由于子问题的重叠，会导致大量无用的重复计算，因此要用到记忆化搜索来提前返回\n核心代码如下\n// 因为题目说每个数都是非负整数，所以d[]初始化为-1，d[i] \u003e= 0 表示未计算 int solve(int i, int j) { if (d[i][j] \u003e= 0) return d[i][j]; // 已经搜索过，直接返回 return d[i][j] = a[i][j] + (i == n ? 0 : max(solve(i+1, j), solve(i+1, j+1))); // 保存计算结果的同时并返回值 } 这里利用了C语言“赋值语句具有返回值”的特性来简化代码\n方法二：递推 注意计算顺序，要从后往前推\n核心代码如下\nvoid solve() { for (int i = 1; i \u003c= n; i++) d[n][i] = a[n][i]; // 初始化最后一层 for (int i = n-1; i \u003e= 1; i--) // 从后往前递推 for (int j = 1; j \u003c= i; j++) d[i][j] = a[i][j] + max(d[i+1][j], d[i+1][j+1]); cout \u003c\u003c d[1][1] \u003c\u003c endl; } 完整代码可参考仓库（附赠数据生成器Python脚本）\nDAG上的动态规划 跟图论扯上关系了（￣▽￣）\n相关笔记：Allen的图论基础\nDAG（Directed Acyclic Graph，有向无环图），即从任意顶点出发无法经过若干条边回到该点的有向图。\n不固定终点的最长路和字典序 例题：嵌套矩形。 题意：给出若干个矩形，选出尽量多的矩形拍成一排，使得除了最后一个之外，每一个矩形都可以嵌套（矩形的长和宽必须严格小于下一个矩形的长和宽；矩形可以旋转）在下一个矩形内。如果有多解，矩形编号的字典序应尽量小\n可以看出，“嵌套”是一个二元关系，可以用图来表示。我们使用邻接矩阵来存图\n状态转移方程为：$ d(i) = max\\{d(i), d(j)+1\\} $\n代码如下：\n#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #include #include #include using namespace std; const int N = 100 + 10; int n; int G[N][N], a[N], b[N], d[N]; // d[i] 表示从结点 i 出发的最长路长度 // 读入数据并建图 void read_input() { cin \u003e\u003e n; int x, y; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e x \u003e\u003e y; a[i] = min(x, y); b[i] = max(x, y); } for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) if (a[i] \u003c a[j] \u0026\u0026 b[i] \u003c b[j]) G[i][j] = 1; } // 记忆化搜索，注意 d[] 要初始化为0 int dp(int i) { int \u0026ans = d[i]; // 用引用来简化读写 if (ans \u003e 0) return ans; ans = 1; for (int j = 1; j \u003c= n; j++) if (G[i][j]) ans = max(ans, dp(j)+1); return ans; } // 递归打印答案，保证字典序最小：尽量选择最小的 i 和 j void print_ans(int i) { cout \u003c\u003c i \u003c\u003c ' '; for (int j = 1; j \u003c= n; j++) if (G[i][j] \u0026\u0026 d[i] == d[j]+1) { print_ans(j); break; // 递归返回后退出循环 } } int main() { #ifdef LOCAL freopen(\"nested_rectangle.in\", \"r\", stdin); freopen(\"nested_rectangle_.out\", \"w\", stdout); #endif int t; cin \u003e\u003e t; while (t--) { memset(d, 0, sizeof(d)); memset(G, 0, sizeof(G)); read_input(); for (int i = 1; i \u003c= n; i++) dp(i); int Max = -1, maxi = 1; for (int i = 1; i \u003c= n; i++) if (d[i] \u003e Max) { Max = d[i]; maxi = i; } print_ans(maxi); cout \u003c\u003c \"\\n\\n\"; } return 0; } EX: UVa 437 The Tower of Babylon\n例题的升级版，只是多了一个维度，完全可以套用例题的模板\nAC代码参考\n固定终点的最长路和最短路 例题：硬币问题。 有 n 种硬币，面值分别为 V1, V2, … , Vn, 每种都有无限多。\nEX: Uva 1347 Tour\n原题可转化为：两人从同一起点出发，每次其中一人走动，最后都走到终点\nAC代码参考\n附录 参考文献 [1]维基百科·动态规划\n[2]刘汝佳《算法竞赛入门基础（第2版）》\n","wordCount":"494","inLanguage":"zh","image":"https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/cover.jpg","datePublished":"2023-03-13T21:58:57+08:00","dateModified":"2023-03-13T21:58:57+08:00","author":{"@type":"Person","name":"Allen Wu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.allenwu233.com/zh/posts/allen-dynamic-programming/"},"publisher":{"@type":"Organization","name":"逍遥乡 | Allen's World","logo":{"@type":"ImageObject","url":"https://blog.allenwu233.com/favicon/favicon/android-chrome-512x512.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.allenwu233.com/zh/ accesskey=h title="逍遥乡 (Alt + H)"><img src=https://blog.allenwu233.com/img/avatar.png alt aria-label=logo height=35>逍遥乡</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.allenwu233.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.allenwu233.com/zh/about/ title=📋关于><span>📋关于</span></a></li><li><a href=https://blog.allenwu233.com/zh/links/ title=🔗友链><span>🔗友链</span></a></li><li><a href=https://blog.allenwu233.com/zh/categories/ title=📔类别><span>📔类别</span></a></li><li><a href=https://blog.allenwu233.com/zh/archives/ title=📦归档><span>📦归档</span></a></li><li><a href=https://blog.allenwu233.com/zh/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://blog.allenwu233.com/zh/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.allenwu233.com/zh/>主页</a>&nbsp;»&nbsp;<a href=https://blog.allenwu233.com/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Allen的动态规划基础</h1><div class=post-description>状态和状态转移方程</div><div class=post-meta><span title='2023-03-13 21:58:57 +0800 +0800'>2023/03/13</span>&nbsp;·&nbsp;Allen Wu</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#引言>引言</a><ul><li><a href=#概念>概念</a></li><li><a href=#适用情况>适用情况</a></li></ul></li><li><a href=#正文>正文</a><ul><li><a href=#状态和状态转移方程>状态和状态转移方程</a></li><li><a href=#数字三角形>数字三角形</a></li><li><a href=#分析>分析</a></li><li><a href=#dag上的动态规划>DAG上的动态规划</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#参考文献>参考文献</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>来点BGM</p></blockquote><h2 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h2><h3 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h3><p><strong>动态规划（英语：Dynamic programming，简称DP）</strong> 是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><h3 id=适用情况>适用情况<a hidden class=anchor aria-hidden=true href=#适用情况>#</a></h3><ul><li><p><strong>最优子结构性质</strong>。
如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p></li><li><p><strong>无后效性</strong>。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p></li><li><p><strong>子问题重叠性质</strong>。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</p></li></ul><p>——From <a href=https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92>维基百科·动态规划</a></p><p>动态规划其实不是一种具体的算法，而是解决问题的思想和方法。简单来说，动态规划就是把问题分解成一个个子问题，通过求子问题的最优解得到全局最优解（这就是所谓的<strong>最优子结构（optimal substructure）</strong>）</p><h2 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h2><h3 id=状态和状态转移方程>状态和状态转移方程<a hidden class=anchor aria-hidden=true href=#状态和状态转移方程>#</a></h3><p>动态规划的核心是<strong>状态</strong>和<strong>状态转移方程</strong></p><blockquote><p>动态规划中状态就是子问题的结果，而本阶段的状态往往是上一阶段状态和上一阶段决策的结果，描述这种前后阶段关系的方程，就是<strong>状态转移方程</strong></p></blockquote><p>如 $ f(i, j) = \max \{f(i, k) , f(k+1, j)+1\} $ 就是一个状态转移方程</p><p>来看看几道例题</p><h3 id=数字三角形>数字三角形<a hidden class=anchor aria-hidden=true href=#数字三角形>#</a></h3><blockquote><p>题目：有一个由非负整数组成的三角形，第一行只有一个数。从第一行的数开始，每次可以往左下或右下走一格，直到走到最下行，把沿途经过的数加起来，求怎么走才能使得数字之和最大？</p></blockquote><p>数字三角形如下所示：</p><pre tabindex=0><code>      1
     / \
    3   2
   / \ / \
  4   10  1
 / \ / \ / \
4   3   2   20
</code></pre><h3 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h3><h4 id=贪心法>贪心法？<a hidden class=anchor aria-hidden=true href=#贪心法>#</a></h4><p>按照贪心法，求出的路径为：<code>1 --> 3 --> 10 --> 3</code></p><p>而实际最大和的路径为：<code>1 --> 2 --> 1 --> 20</code></p><p>显然，贪心法不能保证全局最优解</p><h4 id=回溯法>回溯法？<a hidden class=anchor aria-hidden=true href=#回溯法>#</a></h4><p>每一个结点都有两种选择，如果用回溯法求出所有可能的的路径，就能找到最优解</p><p>然而回溯法的效率太低：一个$ n $层的三角形有 $ 2^{n-1} $ 条路线，复杂度之大让人无法接受</p><p>可以看出，这是一个动态的决策问题——每次可以选择往左下走或往右下走，由此引出我们今天的主角——动态规划</p><h4 id=动态规划>动态规划<a hidden class=anchor aria-hidden=true href=#动态规划>#</a></h4><p>假设用下三角矩阵（主对角线上方所有元素为0的二维数组）<code>a</code>、<code>d</code>分别存储数字三角形和<code>d[i][j]</code>出发路径的最大和</p><p>根据动态规划的思想，求第一层（<code>d[1][1]</code>，即整个数字三角形路径的最大和）出发的最大和，得先求出从第二层出发的最大和；求第二层出发的最大和，得先求出从第三层出发的最大和&mldr;&mldr;由此类推，我们可以把整个问题分解成多个子问题。显然，这道题符合动态规划的条件：</p><ul><li><strong>最优子结构性质</strong>。求出第<code>n</code>层的最优解，就能求出第<code>n-1</code>层的最优解，子问题的最优解最终保证整个问题的最优解</li><li><strong>无后效性</strong>。第<code>n</code>层的最优解一旦确定，就不受前面层的影响</li><li><strong>子问题重叠性质</strong>。比如要计算<code>d[2][1]</code>,就要先计算<code>d[3][1]</code>和<code>d[3][2]</code>；而要计算<code>d[2][2]</code>,也要先计算<code>d[3][2]</code>。由此可见问题的解答树大量重叠，正是动态规划的用武之地</li></ul><p>状态转移方程如下</p><p>$ d(i, j) = a(i, j) + max\{d(i+1, j), d(i+1, j+1)\} $</p><p>下面介绍两种基本的动态规划写法</p><h5 id=方法一记忆化搜索>方法一：记忆化搜索<a hidden class=anchor aria-hidden=true href=#方法一记忆化搜索>#</a></h5><p>直接递归的写法是可以的，但由于子问题的重叠，会导致大量无用的重复计算，因此要用到记忆化搜索来提前返回</p><p>核心代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 因为题目说每个数都是非负整数，所以d[]初始化为-1，d[i] &gt;= 0 表示未计算
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>solve</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>  <span class=c1>// 已经搜索过，直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>n</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>max</span><span class=p>(</span><span class=n>solve</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>),</span> <span class=n>solve</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)));</span>  <span class=c1>// 保存计算结果的同时并返回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>这里利用了C语言“赋值语句具有返回值”的特性来简化代码</p><h5 id=方法二递推>方法二：递推<a hidden class=anchor aria-hidden=true href=#方法二递推>#</a></h5><p>注意计算顺序，要从后往前推</p><p>核心代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>solve</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>d</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>i</span><span class=p>];</span>  <span class=c1>// 初始化最后一层
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span>  <span class=c1>// 从后往前递推
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>max</span><span class=p>(</span><span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>完整代码可参考<a href=https://github.com/AllenWu233/algorithm_study/tree/main/chapter_9>仓库</a>（附赠数据生成器Python脚本）</p><h3 id=dag上的动态规划>DAG上的动态规划<a hidden class=anchor aria-hidden=true href=#dag上的动态规划>#</a></h3><p>跟图论扯上关系了（￣▽￣）</p><p>相关笔记：<a href=https://blog-allenwu233.netlify.app/p/allen-graph/>Allen的图论基础</a></p><p><strong>DAG（Directed Acyclic Graph，有向无环图）</strong>，即从任意顶点出发无法经过若干条边回到该点的有向图。</p><h4 id=不固定终点的最长路和字典序>不固定终点的最长路和字典序<a hidden class=anchor aria-hidden=true href=#不固定终点的最长路和字典序>#</a></h4><blockquote><p>例题：嵌套矩形。
题意：给出若干个矩形，选出尽量多的矩形拍成一排，使得除了最后一个之外，每一个矩形都可以嵌套（矩形的长和宽必须严格小于下一个矩形的长和宽；矩形可以旋转）在下一个矩形内。如果有多解，矩形编号的字典序应尽量小</p></blockquote><p>可以看出，“嵌套”是一个二元关系，可以用图来表示。我们使用邻接矩阵来存图</p><p>状态转移方程为：$ d(i) = max\{d(i), d(j)+1\} $</p><p>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=mi>100</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>G</span><span class=p>[</span><span class=n>N</span><span class=p>][</span><span class=n>N</span><span class=p>],</span> <span class=n>a</span><span class=p>[</span><span class=n>N</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>N</span><span class=p>],</span> <span class=n>d</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>  <span class=c1>// d[i] 表示从结点 i 出发的最长路长度
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 读入数据并建图
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>read_input</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=n>G</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 记忆化搜索，注意 d[] 要初始化为0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>dp</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>&amp;</span><span class=n>ans</span> <span class=o>=</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>  <span class=c1>// 用引用来简化读写
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ans</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ans</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>G</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span> <span class=n>dp</span><span class=p>(</span><span class=n>j</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 递归打印答案，保证字典序最小：尽量选择最小的 i 和 j
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print_ans</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=k>if</span> <span class=p>(</span><span class=n>G</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>d</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print_ans</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>  <span class=c1>// 递归返回后退出循环
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef LOCAL
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>freopen</span><span class=p>(</span><span class=s>&#34;nested_rectangle.in&#34;</span><span class=p>,</span> <span class=s>&#34;r&#34;</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>freopen</span><span class=p>(</span><span class=s>&#34;nested_rectangle_.out&#34;</span><span class=p>,</span> <span class=s>&#34;w&#34;</span><span class=p>,</span> <span class=n>stdout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=kt>int</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>t</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>d</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>G</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>read_input</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>dp</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>Max</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>maxi</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>Max</span><span class=p>)</span> <span class=p>{</span> <span class=n>Max</span> <span class=o>=</span> <span class=n>d</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>maxi</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>print_ans</span><span class=p>(</span><span class=n>maxi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>EX: <a href=https://www.luogu.com.cn/problem/UVA437>UVa 437 The Tower of Babylon</a></p></blockquote><p>例题的升级版，只是多了一个维度，完全可以套用例题的模板</p><p><a href=https://github.com/AllenWu233/algorithm_study/blob/main/chapter_9/uva437_the_tower_of_babylon.cpp>AC代码参考</a></p><h4 id=固定终点的最长路和最短路>固定终点的最长路和最短路<a hidden class=anchor aria-hidden=true href=#固定终点的最长路和最短路>#</a></h4><blockquote><p>例题：硬币问题。
有 n 种硬币，面值分别为 V1, V2, &mldr; , Vn, 每种都有无限多。</p></blockquote><blockquote><p>EX: <a href=https://www.luogu.com.cn/problem/UVA1347>Uva 1347 Tour</a></p></blockquote><p>原题可转化为：两人从同一起点出发，每次其中一人走动，最后都走到终点</p><p><a href=https://github.com/AllenWu233/algorithm_study/blob/main/chapter_9/uva1347_tour.cpp>AC代码参考</a></p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h3><p>[1]<a href=https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92>维基百科·动态规划</a></p><p>[2]刘汝佳《算法竞赛入门基础（第2版）》</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.allenwu233.com/zh/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://blog.allenwu233.com/zh/tags/acm/>ACM</a></li><li><a href=https://blog.allenwu233.com/zh/tags/dp/>DP</a></li></ul><nav class=paginav><a class=prev href=https://blog.allenwu233.com/zh/posts/contest-1822/><span class=title>« 上一页</span><br><span>Codeforces Round 867 (Div. 3) 题解</span>
</a><a class=next href=https://blog.allenwu233.com/zh/posts/allen-graph/><span class=title>下一页 »</span><br><span>Allen的图论基础</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=AllenWu233/myblog-comments data-repo-id=R_kgDOOydlkQ data-category=Announcements data-category-id=DIC_kwDOOydlkc4CquRj data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=transparent_dark data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 - 2025 <a href=https://blog.allenwu233.com/zh/>逍遥乡 | Allen's World</a></span>
<a href="https://icp.gov.moe/?keyword=20250495" target=_blank>萌ICP备20250495号</a> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>