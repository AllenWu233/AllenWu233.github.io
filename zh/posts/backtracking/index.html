<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>生成和检查的有机结合-回溯法 | 逍遥乡 | Allen's World</title>
<meta name=keywords content="算法,Python,C++"><meta name=description content="减少不必要的枚举"><meta name=author content="Allen Wu"><link rel=canonical href=https://blog.allenwu233.com/zh/posts/backtracking/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.allenwu233.com/favicon/favicon/android-chrome-512x512.png><link rel=icon type=image/png sizes=16x16 href=https://blog.allenwu233.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.allenwu233.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.allenwu233.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://blog.allenwu233.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.allenwu233.com/zh/posts/backtracking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://blog.allenwu233.com/zh/posts/backtracking/"><meta property="og:site_name" content="逍遥乡 | Allen's World"><meta property="og:title" content="生成和检查的有机结合-回溯法"><meta property="og:description" content="减少不必要的枚举"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-03T20:00:00+08:00"><meta property="article:modified_time" content="2023-01-12T12:16:00+08:00"><meta property="article:tag" content="算法"><meta property="article:tag" content="Python"><meta property="article:tag" content="C++"><meta property="og:image" content="https://blog.allenwu233.com/img/backtracking_cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.allenwu233.com/img/backtracking_cover.jpg"><meta name=twitter:title content="生成和检查的有机结合-回溯法"><meta name=twitter:description content="减少不必要的枚举"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.allenwu233.com/zh/posts/"},{"@type":"ListItem","position":2,"name":"生成和检查的有机结合-回溯法","item":"https://blog.allenwu233.com/zh/posts/backtracking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"生成和检查的有机结合-回溯法","name":"生成和检查的有机结合-回溯法","description":"减少不必要的枚举","keywords":["算法","Python","C++"],"articleBody":"引言 暴力搜索法（又称 穷举搜索，在计算机科学中也称生成与测试）是一种“简单粗暴地”处理问题的方法，通过枚举所有的可能并判断是否符合题意，以得出答案\n但有时候直接枚举会带来问题：枚举量过大而存在大量不必要的枚举，导致算法时间复杂度过大（太低效了）。有没有更好的方法呢？\n回溯法（backtracking） 是暴力搜索法的一种，可在递归构造中把搜索和检查有机地结合起来，从而减小枚举量\n让我们通过几道经典的题目来感受一下回溯法的魅力吧～\n八皇后问题 可以说是最经典的题目之一了。甚至常被作为“判断有没有学过回溯法”的依据 （刘老师如是说）\n如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。 八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解。——From 维基百科·八皇后问题\n而我们要解决的，正是推广后的n皇后问题。但为了方便描述，下面的分析还是以八皇后问题为例\n思路一：组合生成 枚举出所有可能的棋局，再来判断是否符合题目要求。\n问题可以转换为：从 $ 8 \\times 8 = 64 $ 个格子里选出 $8$ 个（即组合生成），保证任两个格子都不能处于同一条横行、纵行或斜线上\n根据排列组合，我们知道共有$ C_{64}^{8} = 4.426 \\times 10^9 $种方案，显然是太复杂了。\n思路二：全排列生成 稍加思考，我们可以改进策略：恰好每行每列各选一个格子，保证任两个格子都在同一斜线上。如此转化为全排列生成的问题，方案数降为$ 8! = 40320 $种，肉眼可见的效率提升啊（笑）\n我们可以用C[x]表示第x行皇后的列编号。难点之一是如何判断皇后间是否斜向攻击。\n把棋盘看作一个以左上角为原点、往下为x轴、往右为y轴的平面直角坐标系，于是棋盘的主对角线就是 $ y = x $ ，于是对于格子$ (x,y) $， $ y-x $ 的值就标识了主对角线（确保你理解了这一点！）。同理，副对角线为 $ y = -x $ ， $ x+y $ 的值标记了副对角线。如下图所示：\n回溯法 接下来，就要用到回溯法了：\n所谓回溯（backtracking），就是指在递归求解问题时，如果当前步骤没有合法选择，则函数返回上一级递归调用\n简单来说，就是把问题分成若干个步骤递归求解，当某一步不合题意时停止，返回上一步。这样可以大大减少运算量\n来看看代码吧～\n普通回溯法 nqueens_1.cpp\n// n皇后问题：在n*n棋盘上放置n个皇后，使得它们互不攻击，找出所有解 #include #include using namespace std; int C[50], tot = 0, n = 8, nc = 0; // C[x]表示第x行皇后的列编号 void search(int cur) { nc++; // 递归次数 if (cur == n) tot++; // 递归边界。只要走到了这里，所有皇后必然不冲突 // if (cur == n) // 打印解 // { // printf(\"解%d: \", tot); // for (int i = 0; i \u003c n; i++) // printf(\"(%d,%d) \", i, C[i]); // printf(\"\\n\"); // } else for (int i = 0; i \u003c n; i++) { int ok = 1; C[cur] = i; // 尝试把第cur行的皇后放在第i列 for (int j = 0; j \u003c cur; j++) // 检查是否和前面的皇后冲突 // 对于(x,y),y-x值为主对角线，y+x值为副对角线 if (C[cur] == C[j] || cur-C[cur] == j-C[j] || cur+C[cur] == j+C[j]) { ok = 0; break; } if (ok) search(cur+1); // 如果合法，则继续递归 } } int main() { while (cin \u003e\u003e n) { search(0); cout \u003c\u003c \"解的个数: \" \u003c\u003c tot \u003c\u003c endl; cout \u003c\u003c \"递归次数: \" \u003c\u003c nc \u003c\u003c endl; nc = 0; tot = 0; memset(C, 0, sizeof(C)); } return 0; } 这样就解决了这个问题。结点数似乎很难再减少了，但效率还可以提高！\n优化的回溯法 利用二维数组vis[2][]存储状态，来直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。因为$ y-x $可能为负，存储时要加上n（数组下标不能为负）\n#include #include #include using namespace std; int C[50], vis[3][50], tot = 0, n = 8, nc = 0; // 利用二维数组vis[2][]直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后 void search(int cur) { int i; nc++; if (cur == n) tot++; // if(cur == n) // { // printf(\"解%d: \", tot); // for (int i = 0; i \u003c n; i++) // printf(\"(%d,%d) \", i, C[i]); // printf(\"\\n\"); // } else for(i = 0; i \u003c n; i++) { if (!vis[0][i] \u0026\u0026 !vis[1][cur+i] \u0026\u0026 !vis[2][cur-i+n]) { C[cur] = i; // 如果不用打印解，整个C数组都可以省略 vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1; // 访问标记 search(cur+1); vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0; // 及时改回来！ } } } int main() { while (cin \u003e\u003e n) { memset(vis, 0, sizeof(vis)); search(0); cout \u003c\u003c \"解的个数: \" \u003c\u003c tot \u003c\u003c endl; cout \u003c\u003c \"递归次数: \" \u003c\u003c nc \u003c\u003c endl; tot = 0; nc = 0; } return 0; } 注意访问标记的设置，即对辅助全局变量（数组vis）的修改，并且在结束访问后即使修改回来！\n生成 - 测试法 作为比较，我们看看生成 - 测试法的效率如何\nnqueens_3.cpp\n#include #include using namespace std; int C[50], tot = 0, n = 8; long long nc = 0; // 先生成棋面，再判断 void search(int cur) { int i, j; nc++; if(cur == n) { for(i = 0; i \u003c n; i++) for(j = i+1; j \u003c n; j++) if(C[i] == C[j] || i-C[i] == j-C[j] || i+C[i] == j+C[j]) return; tot++; } else for(i = 0; i \u003c n; i++) { C[cur] = i; search(cur+1); } } int main() { while (cin \u003e\u003e n) { memset(C, 0, sizeof(C)); search(0); cout \u003c\u003c \"解的个数: \" \u003c\u003c tot \u003c\u003c endl; cout \u003c\u003c \"递归次数: \" \u003c\u003c nc \u003c\u003c endl; tot = 0; nc = 0; } return 0; } 我们来对比一下这几个程序的效率（测试设备CPU为i9-12900H）\n递归次数\n程序 \\ n 8 9 10 11 12 13 14 15 16 nqueen_1.cpp 2057 8394 35539 166926 856189 4674890 27358553 171129072 1141190303 nqueen_2.cpp 2057 8394 35539 166926 856189 4674890 27358553 171129072 1141190303 nqueen_3.cpp 19173961 435848050 11111111111 - - - - - - 耗时（单位：s）\n程序 \\ n 8 9 10 11 12 13 14 15 16 nqueen_1.cpp 0.001 0.002 0.006 0.028 0.147 0.877 5.582 38.462 284.097 nqueen_2.cpp 0.001 0.002 0.003 0.012 0.056 0.298 1.828 11.761 80.594 nqueen_3.cpp 0.124 3.2 91.716 - - - - - - 当 $ n \\leq 13 $ 时，回溯法和优化后的回溯法有不错的效率；当 $ n \u003e 13 $ 时，优化后回溯法的效率明显更高\n而生成-测试法的复杂度明显高得多，$ n = 10 $ 时耗时长达约一分半，递归次数也远超出INT类型的范围\nPython代码 nqueen.py\ndef print_solve(): global tot, n, C print(f\"解：{tot}\") for i in range(n): print(f\"({i},{C[i]})\", end=\" \") print() def search(cur): global C, vis, tot, n, nc nc += 1 if cur == n: tot += 1 if cur == n: print_solve() else: for i in range(n): if vis[0][i] == 0 and vis[1][cur+i] == 0 and vis[2][cur-i+n] == 0: C[cur] = i vis[0][i] = 1 vis[1][cur+i] = 1 vis[2][cur-i+n] = 1 search(cur+1) vis[0][i] = 0 vis[1][cur+i] = 0 vis[2][cur-i+n] = 0 while 1: C = [0]*30 vis = [[0]*30 for _ in range(3)] tot = 0 n = 0 nc = 0 try: n = int(input()) except: print(\"error.\") search(0) print(f\"解的个数：{tot}\") print(f\"递归次数：{nc}\") 效率飞一般的提升！快去试试吧！\n(To be continue…)\n更新了一些数学公式（终于会用Latex了）——2023/01/12\n附录 参考文献 刘汝佳《算法竞赛入门经典（第2版）》 维基百科·暴力搜索 维基百科·回溯法 维基百科·八皇后问题 ","wordCount":"738","inLanguage":"zh","image":"https://blog.allenwu233.com/img/backtracking_cover.jpg","datePublished":"2022-12-03T20:00:00+08:00","dateModified":"2023-01-12T12:16:00+08:00","author":{"@type":"Person","name":"Allen Wu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.allenwu233.com/zh/posts/backtracking/"},"publisher":{"@type":"Organization","name":"逍遥乡 | Allen's World","logo":{"@type":"ImageObject","url":"https://blog.allenwu233.com/favicon/favicon/android-chrome-512x512.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.allenwu233.com/zh/ accesskey=h title="逍遥乡 (Alt + H)"><img src=https://blog.allenwu233.com/img/avatar.png alt aria-label=logo height=35>逍遥乡</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.allenwu233.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.allenwu233.com/zh/about/ title=📋关于><span>📋关于</span></a></li><li><a href=https://blog.allenwu233.com/zh/links/ title=🔗友链><span>🔗友链</span></a></li><li><a href=https://blog.allenwu233.com/zh/categories/ title=📔类别><span>📔类别</span></a></li><li><a href=https://blog.allenwu233.com/zh/archives/ title=📦归档><span>📦归档</span></a></li><li><a href=https://blog.allenwu233.com/zh/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://blog.allenwu233.com/zh/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.allenwu233.com/zh/>主页</a>&nbsp;»&nbsp;<a href=https://blog.allenwu233.com/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">生成和检查的有机结合-回溯法</h1><div class=post-description>减少不必要的枚举</div><div class=post-meta><span title='2022-12-03 20:00:00 +0800 +0800'>2022/12/03</span>&nbsp;·&nbsp;Allen Wu</div></header><figure class=entry-cover><img loading=eager src=https://blog.allenwu233.com/img/backtracking_cover.jpg alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#八皇后问题>八皇后问题</a><ul><li><a href=#思路一组合生成>思路一：组合生成</a></li><li><a href=#思路二全排列生成>思路二：全排列生成</a></li><li><a href=#回溯法>回溯法</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#参考文献>参考文献</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h2><p><strong>暴力搜索法</strong>（又称 <strong>穷举搜索</strong>，在计算机科学中也称<strong>生成与测试</strong>）是一种“简单粗暴地”处理问题的方法，通过枚举所有的可能并判断是否符合题意，以得出答案</p><p>但有时候直接枚举会带来问题：枚举量过大而存在大量不必要的枚举，导致算法时间复杂度过大（太低效了）。有没有更好的方法呢？</p><blockquote><p><strong>回溯法（backtracking）</strong> 是<strong>暴力搜索法</strong>的一种，可在递归构造中把搜索和检查有机地结合起来，从而减小枚举量</p></blockquote><p>让我们通过几道经典的题目来感受一下回溯法的魅力吧～</p><h2 id=八皇后问题>八皇后问题<a hidden class=anchor aria-hidden=true href=#八皇后问题>#</a></h2><p>可以说是最经典的题目之一了。甚至常被作为“判断有没有学过回溯法”的依据 <del>（刘老师如是说）</del></p><blockquote><p>如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。
八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解。——From <a href=https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98>维基百科·八皇后问题</a></p></blockquote><p>而我们要解决的，正是推广后的n皇后问题。但为了方便描述，下面的分析还是以八皇后问题为例</p><h3 id=思路一组合生成>思路一：组合生成<a hidden class=anchor aria-hidden=true href=#思路一组合生成>#</a></h3><p>枚举出所有可能的棋局，再来判断是否符合题目要求。</p><p>问题可以转换为：从 $ 8 \times 8 = 64 $ 个格子里选出 $8$ 个（即组合生成），保证任两个格子都不能处于同一条横行、纵行或斜线上</p><p>根据排列组合，我们知道共有$ C_{64}^{8} = 4.426 \times 10^9 $种方案，显然是太复杂了。</p><h3 id=思路二全排列生成>思路二：全排列生成<a hidden class=anchor aria-hidden=true href=#思路二全排列生成>#</a></h3><p>稍加思考，我们可以改进策略：恰好每行每列各选一个格子，保证任两个格子都在同一斜线上。如此转化为全排列生成的问题，方案数降为$ 8! = 40320 $种，肉眼可见的效率提升啊（笑）</p><p>我们可以用C[x]表示第x行皇后的列编号。难点之一是如何判断皇后间是否斜向攻击。</p><p>把棋盘看作一个以左上角为原点、往下为x轴、往右为y轴的平面直角坐标系，于是棋盘的<strong>主对角线</strong>就是 $ y = x $ ，于是对于格子$ (x,y) $， $ y-x $ 的值就标识了主对角线（确保你理解了这一点！）。同理，副对角线为 $ y = -x $ ， $ x+y $ 的值标记了副对角线。如下图所示：</p><p><img alt=y-x loading=lazy src=y-x.jpg> <img alt=x+y loading=lazy src=x+y.jpg></p><h3 id=回溯法>回溯法<a hidden class=anchor aria-hidden=true href=#回溯法>#</a></h3><p>接下来，就要用到回溯法了：</p><blockquote><p>所谓<strong>回溯（backtracking）</strong>，就是指在递归求解问题时，如果当前步骤没有合法选择，则函数返回上一级递归调用</p></blockquote><p>简单来说，就是把问题分成若干个步骤递归求解，当某一步不合题意时停止，返回上一步。这样可以大大减少运算量</p><p>来看看代码吧～</p><h4 id=普通回溯法>普通回溯法<a hidden class=anchor aria-hidden=true href=#普通回溯法>#</a></h4><blockquote><p>nqueens_1.cpp</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// n皇后问题：在n*n棋盘上放置n个皇后，使得它们互不攻击，找出所有解
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>C</span><span class=p>[</span><span class=mi>50</span><span class=p>],</span> <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span> <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// C[x]表示第x行皇后的列编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>search</span><span class=p>(</span><span class=kt>int</span> <span class=n>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nc</span><span class=o>++</span><span class=p>;</span>  <span class=c1>// 递归次数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>cur</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=n>tot</span><span class=o>++</span><span class=p>;</span>  <span class=c1>// 递归边界。只要走到了这里，所有皇后必然不冲突
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// if (cur == n)  // 打印解
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     printf(&#34;解%d: &#34;, tot);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     for (int i = 0; i &lt; n; i++)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//         printf(&#34;(%d,%d) &#34;, i, C[i]);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     printf(&#34;\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ok</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>  <span class=c1>// 尝试把第cur行的皇后放在第i列
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>cur</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>  <span class=c1>// 检查是否和前面的皇后冲突
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 对于(x,y),y-x值为主对角线，y+x值为副对角线
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>==</span> <span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>||</span> <span class=n>cur</span><span class=o>-</span><span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>==</span> <span class=n>j</span><span class=o>-</span><span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>||</span> <span class=n>cur</span><span class=o>+</span><span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>==</span> <span class=n>j</span><span class=o>+</span><span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=n>ok</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=k>break</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>)</span> <span class=n>search</span><span class=p>(</span><span class=n>cur</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>  <span class=c1>// 如果合法，则继续递归
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>search</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;解的个数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tot</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;递归次数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>nc</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>memset</span><span class=p>(</span><span class=n>C</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>C</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样就解决了这个问题。结点数似乎很难再减少了，但效率还可以提高！</p><h4 id=优化的回溯法>优化的回溯法<a hidden class=anchor aria-hidden=true href=#优化的回溯法>#</a></h4><p>利用二维数组<code>vis[2][]</code>存储状态，来直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。因为$ y-x $可能为负，存储时要加上<code>n</code>（数组下标不能为负）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>C</span><span class=p>[</span><span class=mi>50</span><span class=p>],</span> <span class=n>vis</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>50</span><span class=p>],</span> <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span> <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 利用二维数组vis[2][]直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>search</span><span class=p>(</span><span class=kt>int</span> <span class=n>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nc</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cur</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=n>tot</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// if(cur == n)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     printf(&#34;解%d: &#34;, tot);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     for (int i = 0; i &lt; n; i++)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//         printf(&#34;(%d,%d) &#34;, i, C[i]);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     printf(&#34;\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>  <span class=c1>// 如果不用打印解，整个C数组都可以省略
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 访问标记
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>search</span><span class=p>(</span><span class=n>cur</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// 及时改回来！
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>vis</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>vis</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>search</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;解的个数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tot</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;递归次数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>nc</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意访问标记的设置，即对辅助全局变量（数组vis）的修改，并且在结束访问后即使修改回来！</p><h4 id=生成---测试法>生成 - 测试法<a hidden class=anchor aria-hidden=true href=#生成---测试法>#</a></h4><p>作为比较，我们看看生成 - 测试法的效率如何</p><blockquote><p>nqueens_3.cpp</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>C</span><span class=p>[</span><span class=mi>50</span><span class=p>],</span> <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=kt>long</span> <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 先生成棋面，再判断
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>search</span><span class=p>(</span><span class=kt>int</span> <span class=n>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nc</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cur</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>||</span> <span class=n>i</span><span class=o>-</span><span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>j</span><span class=o>-</span><span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>||</span> <span class=n>i</span><span class=o>+</span><span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>j</span><span class=o>+</span><span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tot</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>search</span><span class=p>(</span><span class=n>cur</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>C</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>C</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>search</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;解的个数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tot</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;递归次数: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>nc</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们来对比一下这几个程序的效率（测试设备CPU为i9-12900H）</p><blockquote><p>递归次数</p></blockquote><table><thead><tr><th style=text-align:center>程序 \ n</th><th style=text-align:center>8</th><th style=text-align:center>9</th><th style=text-align:center>10</th><th style=text-align:center>11</th><th style=text-align:center>12</th><th style=text-align:center>13</th><th style=text-align:center>14</th><th style=text-align:center>15</th><th style=text-align:center>16</th></tr></thead><tbody><tr><td style=text-align:center>nqueen_1.cpp</td><td style=text-align:center>2057</td><td style=text-align:center>8394</td><td style=text-align:center>35539</td><td style=text-align:center>166926</td><td style=text-align:center>856189</td><td style=text-align:center>4674890</td><td style=text-align:center>27358553</td><td style=text-align:center>171129072</td><td style=text-align:center>1141190303</td></tr><tr><td style=text-align:center>nqueen_2.cpp</td><td style=text-align:center>2057</td><td style=text-align:center>8394</td><td style=text-align:center>35539</td><td style=text-align:center>166926</td><td style=text-align:center>856189</td><td style=text-align:center>4674890</td><td style=text-align:center>27358553</td><td style=text-align:center>171129072</td><td style=text-align:center>1141190303</td></tr><tr><td style=text-align:center>nqueen_3.cpp</td><td style=text-align:center>19173961</td><td style=text-align:center>435848050</td><td style=text-align:center>11111111111</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><blockquote><p>耗时（单位：s）</p></blockquote><table><thead><tr><th style=text-align:center>程序 \ n</th><th style=text-align:center>8</th><th style=text-align:center>9</th><th style=text-align:center>10</th><th style=text-align:center>11</th><th style=text-align:center>12</th><th style=text-align:center>13</th><th style=text-align:center>14</th><th style=text-align:center>15</th><th style=text-align:center>16</th><th></th></tr></thead><tbody><tr><td style=text-align:center>nqueen_1.cpp</td><td style=text-align:center>0.001</td><td style=text-align:center>0.002</td><td style=text-align:center>0.006</td><td style=text-align:center>0.028</td><td style=text-align:center>0.147</td><td style=text-align:center>0.877</td><td style=text-align:center>5.582</td><td style=text-align:center>38.462</td><td style=text-align:center>284.097</td><td></td></tr><tr><td style=text-align:center>nqueen_2.cpp</td><td style=text-align:center>0.001</td><td style=text-align:center>0.002</td><td style=text-align:center>0.003</td><td style=text-align:center>0.012</td><td style=text-align:center>0.056</td><td style=text-align:center>0.298</td><td style=text-align:center>1.828</td><td style=text-align:center>11.761</td><td style=text-align:center>80.594</td><td></td></tr><tr><td style=text-align:center>nqueen_3.cpp</td><td style=text-align:center>0.124</td><td style=text-align:center>3.2</td><td style=text-align:center>91.716</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td></td></tr></tbody></table><p>当 $ n \leq 13 $ 时，回溯法和优化后的回溯法有不错的效率；当 $ n > 13 $ 时，优化后回溯法的效率明显更高</p><p>而生成-测试法的复杂度明显高得多，$ n = 10 $ 时耗时长达约一分半，递归次数也远超出INT类型的范围</p><h4 id=python代码>Python代码<a hidden class=anchor aria-hidden=true href=#python代码>#</a></h4><blockquote><p>nqueen.py</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>print_solve</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>tot</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>C</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;解：</span><span class=si>{</span><span class=n>tot</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;(</span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>,</span><span class=si>{</span><span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=si>}</span><span class=s2>)&#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=n>cur</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>C</span><span class=p>,</span> <span class=n>vis</span><span class=p>,</span> <span class=n>tot</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>nc</span>
</span></span><span class=line><span class=cl>    <span class=n>nc</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>cur</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tot</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>cur</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>print_solve</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>C</span><span class=p>[</span><span class=n>cur</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>search</span><span class=p>(</span><span class=n>cur</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>cur</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=n>vis</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>cur</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>C</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=mi>30</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>tot</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>nc</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;error.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>search</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;解的个数：</span><span class=si>{</span><span class=n>tot</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;递归次数：</span><span class=si>{</span><span class=n>nc</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>效率飞一般的提升！快去试试吧！</p><p>(To be continue&mldr;)</p><p>更新了一些数学公式（终于会用Latex了）——2023/01/12</p><p><img alt=Rumia_pid71105196 loading=lazy src=/img/71105196_p0_master1200.jpg></p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h3><ol><li>刘汝佳《算法竞赛入门经典（第2版）》</li><li><a href=https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2>维基百科·暴力搜索</a></li><li><a href=https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95>维基百科·回溯法</a></li><li><a href=https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98>维基百科·八皇后问题</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.allenwu233.com/zh/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://blog.allenwu233.com/zh/tags/python/>Python</a></li><li><a href=https://blog.allenwu233.com/zh/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://blog.allenwu233.com/zh/posts/8-nums/><span class=title>« 上一页</span><br><span>路径寻找-八数码问题</span>
</a><a class=next href=https://blog.allenwu233.com/zh/posts/little-reimu/><span class=title>下一页 »</span><br><span>记忆、爱与救赎</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=AllenWu233/AllenWu233.github.io data-repo-id=R_kgDOOUVoCw data-category=Announcements data-category-id=DIC_kwDOOUVoC84Co2ps data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=transparent_dark data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 - 2025 <a href=https://blog.allenwu233.com/zh/>逍遥乡 | Allen's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>