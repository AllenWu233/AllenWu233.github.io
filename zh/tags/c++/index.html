<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | Allen's World</title>
<meta name=keywords content><meta name=description content="Allen's blog"><meta name=author content><link rel=canonical href=https://blog.allenwu233.com/zh/tags/c++/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.allenwu233.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.allenwu233.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.allenwu233.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.allenwu233.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.allenwu233.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.allenwu233.com/zh/tags/c++/index.xml><link rel=alternate hreflang=zh href=https://blog.allenwu233.com/zh/tags/c++/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://blog.allenwu233.com/zh/tags/c++/"><meta property="og:site_name" content="Allen's World"><meta property="og:title" content="C++"><meta property="og:description" content="Allen's blog"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content="Allen's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.allenwu233.com/zh/ accesskey=h title="Allen's World (Alt + H)"><img src=https://blog.allenwu233.com/apple-touch-icon.png alt aria-label=logo height=35>Allen's World</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.allenwu233.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.allenwu233.com/zh/about/ title=📋关于><span>📋关于</span></a></li><li><a href=https://blog.allenwu233.com/zh/links/ title=🔗友链><span>🔗友链</span></a></li><li><a href=https://blog.allenwu233.com/zh/archives/ title=📦归档><span>📦归档</span></a></li><li><a href=https://blog.allenwu233.com/zh/tags/ title=📜标签><span>📜标签</span></a></li><li><a href=https://blog.allenwu233.com/zh/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.allenwu233.com/zh/>主页</a>&nbsp;»&nbsp;<a href=https://blog.allenwu233.com/zh/tags/>Tags</a></div><h1>C++
<a href=/zh/tags/c++/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>路径寻找-八数码问题</h2></header><div class=entry-content><p>题目 玩过华容道吧？或者是Win7自带小挂件的数字滑块游戏？八数码问题就是从这个游戏引申出来的：
给定编号为1～8的正方形滑块，排成 $ 3 \times 3 $ ，其中有一个格子留空。每次操作可以把一个与空格相邻滑块移动到空格内。给定初始局面和目标局面（空格用0表示），求最少移动步数，若无法到达目标局面，则输出-1
分析 可以看出，这也是BFS求最短路。但要注意判重，即避免同一个访问多次，否则会相当浪费时间和空间
对于本题， 哈希（Hash） 是一种可行而高效的方法。简单来说，就是设计一个函数 $ h(x) $ ，把任意结点$ x $映射到 $ [0, M-1] $ 内的整数即可，其中$ M $根据可用内存大小自选。在理想情况下，只需开一个大小为$ M $的数组就能判重。但有时候不同结点的哈希值可能相同，就需要把哈希值相同的状态组织成链表
代码 出自紫书
有几处值得学习的小技巧，比如定义“状态”类型、用两个数组来模拟单向链表、用“引用”简化代码等
eight_nums.cpp
#include &lt;iostream> #include &lt;cstring> using namespace std; typedef int State[9]; // 定义“状态”类型 const int MAXSTATE = 1e6; State st[MAXSTATE], goal; // 状态数组。所有状态都保存在这里 int dist[MAXSTATE]; // 距离数组 const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, -1, 1}; const int MAX_HASH_SIZE = 1e6 + 3; int head[MAX_HASH_SIZE], next_[MAXSTATE]; // 模拟单向链表 void init_lookup_table() { // 初始化查找表 memset(head, 0, sizeof(head)); } int myhash(State &amp;s) { // 哈希函数； int v = 0; for (int i = 0; i &lt; 9; i++) v = v * 10 + s[i]; // 把9个数字合成9位数 return v % MAX_HASH_SIZE; // 确保hash函数是不超过hash表的大小的非负整数 } int try_to_insert(int s) { int h = myhash(st[s]); int u = head[h]; // 从表头开始查找链表 while (u) { if (memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0; // 找到了，插入失败 u = next_[u]; // 顺着链表继续找 } next_[s] = head[h]; // 插入到链表中 head[h] = s; return 1; } int bfs() { // BFS，返回目标状态在st数组下标 init_lookup_table(); // 初始化查找表 int front = 1, rear = 2; // 不使用下标0，因为0被看作“不存在” while (front &lt; rear) { State &amp;s = st[front]; // 用“引用”简化代码 if (memcmp(goal, s, sizeof(s)) == 0) return front; // 找到目标状态，成功返回 int z; for (z = 0; z &lt; 9; z++) if (!s[z]) break; // 找“0”的位置 int x = z/3, y = z%3; // 获取行列编号（0~2） for (int d = 0; d &lt; 4; d++) { int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if (newx >= 0 && newx &lt; 3 && newy >= 0 && newy &lt; 3) { // 如果移动合法 State &amp;t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); // 拓展新结点 t[newz] = s[z]; t[z] = s[newz]; dist[rear] = dist[front] + 1; // 更新新结点的距离值 if (try_to_insert(rear)) rear++; // 如果成功插入查找表，修改队尾指针 } } front++; // 拓展完毕后在修改队首指针 } return 0; // 失败 } int main() { #ifdef LOCAL freopen("eight_nums.in", "r", stdin); freopen("eight_nums_.out", "w", stdout); #endif ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); for (int i = 0; i &lt; 9; i++) cin >> st[1][i]; // 起始状态 for (int i = 0; i &lt; 9; i++) cin >> goal[i]; // 目标状态 int ans = bfs(); // 返回目标状态的下标 if (ans > 0) cout &lt;&lt; dist[ans] &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0; } 思考 除了哈希外，还有很多方法，比如编码、A*、STL set（效率低，仅作“跳板”）等，等学到了就来试试（
...</p></div><footer class=entry-footer><span title='2023-01-27 15:47:55 +0800 +0800'>2023/01/27</span></footer><a class=entry-link aria-label="post link to 路径寻找-八数码问题" href=https://blog.allenwu233.com/zh/posts/8-nums/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>生成和检查的有机结合-回溯法</h2></header><div class=entry-content><p>引言 暴力搜索法（又称 穷举搜索，在计算机科学中也称生成与测试）是一种“简单粗暴地”处理问题的方法，通过枚举所有的可能并判断是否符合题意，以得出答案 但有时候直接枚举会带来问题：枚举量过大而存在大量不必要的枚举，导致算法时间复杂度过大（太低效了）。有没有更好的方法呢？
回溯法（backtracking） 是暴力搜索法的一种，可在递归构造中把搜索和检查有机地结合起来，从而减小枚举量
让我们通过几道经典的题目来感受一下回溯法的魅力吧～
八皇后问题 可以说是最经典的题目之一了。甚至常被作为“判断有没有学过回溯法”的依据 （刘老师如是说）
如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。 八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解。——From 维基百科·八皇后问题
而我们要解决的，正是推广后的n皇后问题。但为了方便描述，下面的分析还是以八皇后问题为例
思路一：组合生成 枚举出所有可能的棋局，再来判断是否符合题目要求。
问题可以转换为：从 $ 8 \times 8 = 64 $ 个格子里选出 $8$ 个（即组合生成），保证任两个格子都不能处于同一条横行、纵行或斜线上 根据排列组合，我们知道共有$ C_{64}^{8} = 4.426 \times 10^9 $种方案，显然是太复杂了。
思路二：全排列生成 稍加思考，我们可以改进策略：恰好每行每列各选一个格子，保证任两个格子都在同一斜线上。如此转化为全排列生成的问题，方案数降为$ 8! = 40320 $种，肉眼可见的效率提升啊（笑）
...</p></div><footer class=entry-footer><span title='2022-12-03 20:00:00 +0800 +0800'>2022/12/03</span></footer><a class=entry-link aria-label="post link to 生成和检查的有机结合-回溯法" href=https://blog.allenwu233.com/zh/posts/backtracking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>数据结构之美-二叉树</h2></header><div class=entry-content><p>引言 - 二叉树是什么 在计算机科学中， 二叉树（Binary tree） 是每个结点最多只有两个分支（即不存在分支度大于2的结点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 与普通树不同，普通树的结点个数至少为1，而二叉树的结点个数可以为0；普通树结点的最大分支度没有限制，而二叉树结点的最大分支度为2；普通树的结点无左、右次序之分，而二叉树的结点有左、右次序之分。 ——From 中文维基百科·二叉树
二叉树是非常重要的数据结构，其独特的结构使得它在搜索和处理数据方面有相当不错的表现 二叉树的遍历 层次遍历（宽度优先遍历） 顾名思义，即按从上到下、从左到右的顺序遍历结点 以上图为例，遍历的顺序为1～15 这种方法叫 宽度优先遍历（Breadth-First Search, BFS）
递归遍历（深度优先遍历） 博主认为二叉树的递归遍历是最为精彩的部分。理解其三种递归遍历方式，能一窥二叉树的结构之美
对于一棵二叉树 T ，可以递归定义它的先序遍历、中序遍历和后序遍历，如下所示：
PreOrder(T) = T的根结点 + PreOrder(T的左子树) + PreOrder(T的右子树) InOrder(T) = InOrder(T的左子树) + T的根结点 + InOrder(T的右结点) PostOrder(T) = PostOrder(T的左子树) + PostOrder(T的右子树) + T的根结点 这三种遍历都属于递归遍历，或者说 深度优先遍历（Depth-First Search, DFS） ，因为它总是优先往深处访问 ——From 刘汝佳《算法竞赛入门经典（第2版）》 还是以上图为例，来讲一下如何递归遍历： 要遍历整棵二叉树，首先把1,2,3看作一棵小二叉树来遍历，其中1为根，2,3为结点。遍历结点2或3时，再分别把2,4,5或3,6,7看作小二叉树来遍历，依次类推。具体遍历顺序由遍历的方式而定
...</p></div><footer class=entry-footer><span title='2022-11-06 22:00:00 +0800 +0800'>2022/11/06</span></footer><a class=entry-link aria-label="post link to 数据结构之美-二叉树" href=https://blog.allenwu233.com/zh/posts/binary-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>数据结构初见-栈</h2></header><div class=entry-content><p>如果说算法是程序的灵魂，那么数据结构就如同程序的躯体。 学习数据结构，一定少不了基础而经典的——栈(stack) 那么，栈是什么？
什么是栈 Stack 是东方Project同人音乐社团「暁records」主唱/作词/偶尔作曲/编曲，拥有的独特嗓音,虽然有些人不喜欢,但是从来不会被忽略,一入耳就能留下永远无法忘记的印象…… > 咳咳……正经的：
In computer science, a stack is an abstract data type that serves as a collection of elements, with two main operations:
Push, which adds an element to the collection, and Pop, which removes the most recently added element that was not yet removed. ——from WIKIPEDIA 简言之，栈（stack，又称为堆栈或堆叠）就是符合 “后进先出”(Last In First Out, LIFO) 规则的线性存储结构，有PUSH和POP两种操作
...</p></div><footer class=entry-footer><span title='2022-10-30 14:00:00 +0800 +0800'>2022/10/30</span></footer><a class=entry-link aria-label="post link to 数据结构初见-栈" href=https://blog.allenwu233.com/zh/posts/stack/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.allenwu233.com/zh/>Allen's World</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>